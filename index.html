<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Automatic Certificate Management Environment (ACME)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>
  <style type="text/css">
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}

@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

body {
  font: 11pt cambria, helvetica, arial, sans-serif;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 1em auto;
  max-width: 700px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: candara, helvetica, arial, sans-serif;
  font-size-adjust: 0.5;
}
.title { font-size: 150%; }
h1 { font-size: 130%; }
h2 { font-size: 120%; }
h3, h4 { font-size: 110%; }

table {
  margin-left: 0em;
}
table.header {
  width: 100%;
}

table.header td {
  background-color: inherit;
  color: black;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}

pre.text, pre.text2 {
  width: 90%;
}

dt {
  float: left; clear: left;
  margin: 0.5em 0.5em 0 0;
}
dt:first-child {
  margin-top: 0;
}
dd {
  margin: 0.5em 0 0 2em;
}
dd p, dd ul {
  margin-top: 0; margin-bottom: 0;
}
dd *+p {
  margin-top: 0.5em;
}

ol, ul {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}
ul.toc a:first-child {
  display: inline-block;
  min-width: 1.2em;
}
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Deployment Model and Operator Experience"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Terminology"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Protocol Overview"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Protocol Elements"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 HTTPS Requests"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Registration Objects"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Authorization Objects"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Errors"/>
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Replay protection"/>
<link href="#rfc.section.5.5.1" rel="Chapter" title="5.5.1 Replay-Nonce"/>
<link href="#rfc.section.5.5.2" rel="Chapter" title="5.5.2 &#x201C;nonce&#x201D; (Nonce) JWS header parameter"/>
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Key Agreement"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Certificate Management"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Resources"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Directory"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Registration"/>
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 Recovery Keys"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Account Recovery"/>
<link href="#rfc.section.6.4.1" rel="Chapter" title="6.4.1 MAC-Based Recovery"/>
<link href="#rfc.section.6.4.2" rel="Chapter" title="6.4.2 Contact-Based Recovery"/>
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Identifier Authorization"/>
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Certificate Issuance"/>
<link href="#rfc.section.6.7" rel="Chapter" title="6.7 Certificate Renewal"/>
<link href="#rfc.section.6.8" rel="Chapter" title="6.8 Certificate Revocation"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Identifier Validation Challenges"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Simple HTTP"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Domain Validation with Server Name Indication (DVSNI)"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Proof of Possession of a Prior Key"/>
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 DNS"/>
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Threat model"/>
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Integrity of Authorizations"/>
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Preventing Authorization Hijacking"/>
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Denial-of-Service Considerations"/>
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 CA Policy Considerations"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="11 References"/>
<link href="#rfc.references.1" rel="Chapter" title="11.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="11.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.0 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Barnes, R., Hoffman-Andrews, J., and J. Kasten" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-barnes-acme-03" />
  <meta name="dct.issued" scheme="ISO8601" content="2014-9-01" />
  <meta name="dct.abstract" content="Certificates in the Web&#8217;s X.509 PKI (PKIX) are used for a number of purposes, the most significant of which is the authentication of domain names.  Thus, certificate authorities in the Web PKI are trusted to verify that an applicant for a certificate legitimately represents the domain name(s) in the certificate.  Today, this verification is done through a collection of ad hoc mechanisms.  This document describes a protocol that a certificate authority (CA) and an applicant can use to automate the process of verification and certificate issuance.  The protocol also provides facilities for other certificate management functions, such as certificate revocation." />
  <meta name="description" content="Certificates in the Web&#8217;s X.509 PKI (PKIX) are used for a number of purposes, the most significant of which is the authentication of domain names.  Thus, certificate authorities in the Web PKI are trusted to verify that an applicant for a certificate legitimately represents the domain name(s) in the certificate.  Today, this verification is done through a collection of ad hoc mechanisms.  This document describes a protocol that a certificate authority (CA) and an applicant can use to automate the process of verification and certificate issuance.  The protocol also provides facilities for other certificate management functions, such as certificate revocation." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">R. Barnes</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">J. Hoffman-Andrews</td>
</tr>
<tr>
  <td class="left">Expires: March 5, 2015</td>
  <td class="right">EFF</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">J. Kasten</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">University of Michigan</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">September 01, 2014</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Automatic Certificate Management Environment (ACME)<br />
  <span class="filename">draft-barnes-acme-03</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>Certificates in the Web&#8217;s X.509 PKI (PKIX) are used for a number of purposes, the most significant of which is the authentication of domain names.  Thus, certificate authorities in the Web PKI are trusted to verify that an applicant for a certificate legitimately represents the domain name(s) in the certificate.  Today, this verification is done through a collection of ad hoc mechanisms.  This document describes a protocol that a certificate authority (CA) and an applicant can use to automate the process of verification and certificate issuance.  The protocol also provides facilities for other certificate management functions, such as certificate revocation.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 5, 2015.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2014 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Deployment Model and Operator Experience</a></li>
<li>3.   <a href="#rfc.section.3">Terminology</a></li>
<li>4.   <a href="#rfc.section.4">Protocol Overview</a></li>
<li>5.   <a href="#rfc.section.5">Protocol Elements</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">HTTPS Requests</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Registration Objects</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Authorization Objects</a></li>
<li>5.4.   <a href="#rfc.section.5.4">Errors</a></li>
<li>5.5.   <a href="#rfc.section.5.5">Replay protection</a></li>
<ul><li>5.5.1.   <a href="#rfc.section.5.5.1">Replay-Nonce</a></li>
<li>5.5.2.   <a href="#rfc.section.5.5.2">&#8220;nonce&#8221; (Nonce) JWS header parameter</a></li>
</ul><li>5.6.   <a href="#rfc.section.5.6">Key Agreement</a></li>
</ul><li>6.   <a href="#rfc.section.6">Certificate Management</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Resources</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Directory</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Registration</a></li>
<ul><li>6.3.1.   <a href="#rfc.section.6.3.1">Recovery Keys</a></li>
</ul><li>6.4.   <a href="#rfc.section.6.4">Account Recovery</a></li>
<ul><li>6.4.1.   <a href="#rfc.section.6.4.1">MAC-Based Recovery</a></li>
<li>6.4.2.   <a href="#rfc.section.6.4.2">Contact-Based Recovery</a></li>
</ul><li>6.5.   <a href="#rfc.section.6.5">Identifier Authorization</a></li>
<li>6.6.   <a href="#rfc.section.6.6">Certificate Issuance</a></li>
<li>6.7.   <a href="#rfc.section.6.7">Certificate Renewal</a></li>
<li>6.8.   <a href="#rfc.section.6.8">Certificate Revocation</a></li>
</ul><li>7.   <a href="#rfc.section.7">Identifier Validation Challenges</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Simple HTTP</a></li>
<li>7.2.   <a href="#rfc.section.7.2">Domain Validation with Server Name Indication (DVSNI)</a></li>
<li>7.3.   <a href="#rfc.section.7.3">Proof of Possession of a Prior Key</a></li>
<li>7.4.   <a href="#rfc.section.7.4">DNS</a></li>
</ul><li>8.   <a href="#rfc.section.8">IANA Considerations</a></li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a></li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Threat model</a></li>
<li>9.2.   <a href="#rfc.section.9.2">Integrity of Authorizations</a></li>
<li>9.3.   <a href="#rfc.section.9.3">Preventing Authorization Hijacking</a></li>
<li>9.4.   <a href="#rfc.section.9.4">Denial-of-Service Considerations</a></li>
<li>9.5.   <a href="#rfc.section.9.5">CA Policy Considerations</a></li>
</ul><li>10.   <a href="#rfc.section.10">Acknowledgements</a></li>
<li>11.   <a href="#rfc.references">References</a></li>
<ul><li>11.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>11.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">Certificates in the Web PKI are most commonly used to authenticate domain names.  Thus, certificate authorities in the Web PKI are trusted to verify that an applicant for a certificate legitimately represents the domain name(s) in the certificate.</p>
<p id="rfc.section.1.p.2">Existing Web PKI certificate authorities tend to run on a set of ad hoc protocols for certificate issuance and identity verification.  A typical user experience is something like:</p>
<p/>

<ul>
  <li>Generate a PKCS#10 <a href="#RFC2314">[RFC2314]</a> Certificate Signing Request (CSR).</li>
  <li>Cut-and-paste the CSR into a CA web page.</li>
  <li>Prove ownership of the domain by one of the following methods: <ul><li>Put a CA-provided challenge at a specific place on the web server.</li><li>Put a CA-provided challenge at a DNS location corresponding to the target domain.</li><li>Receive CA challenge at a (hopefully) administrator-controlled e-mail address corresponding to the domain and then respond to it on the CA&#8217;s web page.</li></ul></li>
  <li>Download the issued certificate and install it on their Web Server.</li>
</ul>
<p id="rfc.section.1.p.4">With the exception of the CSR itself and the certificates that are issued, these are all completely ad hoc procedures and are accomplished by getting the human user to follow interactive natural-language instructions from the CA rather than by machine-implemented published protocols.  In many cases, the instructions are difficult to follow and cause significant confusion.  Informal usability tests by the authors indicate that webmasters often need 1-3 hours to obtain and install a certificate for a domain.  Even in the best case, the lack of published, standardized mechanisms presents an obstacle to the wide deployment of HTTPS and other PKIX-dependent systems because it inhibits mechanization of tasks related to certificate issuance, deployment, and revocation.</p>
<p id="rfc.section.1.p.5">This document describes an extensible framework for automating the issuance and domain validation procedure, thereby allowing servers and infrastructural software to obtain certificates without user interaction.  Use of this protocol should radically simplify the deployment of HTTPS and the practicality of PKIX authentication for other protocols based on TLS <a href="#RFC5246">[RFC5246]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#deployment-model-and-operator-experience" id="deployment-model-and-operator-experience">Deployment Model and Operator Experience</a></h1>
<p id="rfc.section.2.p.1">The major guiding use case for ACME is obtaining certificates for Web sites (HTTPS <a href="#RFC2818">[RFC2818]</a>).  In that case, the server is intended to speak for one or more domains, and the process of certificate issuance is intended to verify that the server actually speaks for the domain.</p>
<p id="rfc.section.2.p.2">Different types of certificates reflect different kinds of CA verification of information about the certificate subject.  &#8220;Domain Validation&#8221; (DV) certificates are by far the most common type.  For DV validation, the CA merely verifies that the requester has effective control of the web server and/or DNS server for the domain, but does not explicitly attempt to verify their real-world identity.  (This is as opposed to &#8220;Organization Validation&#8221; (OV) and &#8220;Extended Validation&#8221; (EV) certificates, where the process is intended to also verify the real-world identity of the requester.)</p>
<p id="rfc.section.2.p.3">DV certificate validation commonly checks claims about properties related to control of a domain name &#8211; properties that can be observed by the issuing authority in an interactive process that can be conducted purely online.  That means that under typical circumstances, all steps in the request, verification, and issuance process can be represented and performed by Internet protocols with no out-of-band human intervention.</p>
<p id="rfc.section.2.p.4">When an operator deploys a current HTTPS server, it generally prompts him to generate a self-signed certificate.  When an operator deploys an ACME-compatible web server, the experience would be something like this:</p>
<p/>

<ul>
  <li>The ACME client prompts the operator for the intended domain name(s) that the web server is to stand for.</li>
  <li>The ACME client presents the operator with a list of CAs from which it could get a certificate.  (This list will change over time based on the capabilities of CAs and updates to ACME configuration.) The ACME client might prompt the operator for payment information at this point.</li>
  <li>The operator selects a CA.</li>
  <li>In the background, the ACME client contacts the CA and requests that a certificate be issued for the intended domain name(s).</li>
  <li>Once the CA is satisfied, the certificate is issued and the ACME client automatically downloads and installs it, potentially notifying the operator via e-mail, SMS, etc.</li>
  <li>The ACME client periodically contacts the CA to get updated certificates, stapled OCSP responses, or whatever else would be required to keep the server functional and its credentials up-to-date.</li>
</ul>
<p id="rfc.section.2.p.6">The overall idea is that it&#8217;s nearly as easy to deploy with a CA-issued certificate as a self-signed certificate, and that once the operator has done so, the process is self-sustaining with minimal manual intervention.  Close integration of ACME with HTTPS servers, for example, can allow the immediate and automated deployment of certificates as they are issued, optionally sparing the human administrator from additional configuration work.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#terminology" id="terminology">Terminology</a></h1>
<p id="rfc.section.3.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.3.p.2">The two main roles in ACME are &#8220;client&#8221; and &#8220;server&#8221;.  The ACME client uses the protocol to request certificate management actions, such as issuance or revocation.  An ACME client therefore typically runs on a web server, mail server, or some other server system which requires valid TLS certificates.  The ACME server runs at a certificate authority, and responds to client requests, performing the requested actions if the client is authorized.</p>
<p id="rfc.section.3.p.3">For simplicity, in all HTTPS transactions used by ACME, the ACME client is the HTTPS client and the ACME server is the HTTPS server.</p>
<p id="rfc.section.3.p.4">In the discussion below, we will refer to three different types of keys / key pairs:</p>
<p/>

<dl>
  <dt>Subject Public Key:</dt>
  <dd style="margin-left: 8">A public key to be included in a certificate.</dd>
  <dt>Account Key Pair:</dt>
  <dd style="margin-left: 8">A key pair for which the ACME server considers the holder of the private key authorized to manage certificates for a given identifier.  The same key pair may be authorized for multiple identifiers.</dd>
  <dt>Recovery Key:</dt>
  <dd style="margin-left: 8">A MAC key that can a client can use to demonstrate that it participated in a prior registration transaction.</dd>
</dl>
<p id="rfc.section.3.p.6">ACME messaging is based on HTTPS <a href="#RFC2818">[RFC2818]</a> and JSON <a href="#RFC7159">[RFC7159]</a>.  Since JSON is a text-based format, binary fields are Base64-encoded.  For Base64 encoding, we use the variant defined in <a href="#RFC7515">[RFC7515]</a>.  The important features of this encoding are (1) that it uses the URL-safe character set, and (2) that &#8220;=&#8221; padding characters are stripped.</p>
<p id="rfc.section.3.p.7">Some HTTPS bodies in ACME are authenticated and integrity-protected by being encapsulated in a JSON Web Signature (JWS) object <a href="#RFC7515">[RFC7515]</a>.  ACME uses a profile of JWS, with the following restrictions:</p>
<p/>

<ul>
  <li>The JWS MUST use the Flattened JSON Serialization</li>
  <li>The JWS MUST be encoded using UTF-8</li>
  <li>The JWS Header or Protected Header MUST include &#8220;alg&#8221; and &#8220;jwk&#8221; fields</li>
  <li>The JWS MUST NOT have the value &#8220;none&#8221; in its &#8220;alg&#8221; field</li>
</ul>
<p id="rfc.section.3.p.9">Additionally, JWS objects used in ACME MUST include the &#8220;nonce&#8221; header parameter, defined below.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#protocol-overview" id="protocol-overview">Protocol Overview</a></h1>
<p id="rfc.section.4.p.1">ACME allows a client to request certificate management actions using a set of JSON messages carried over HTTPS.   In some ways, ACME functions much like a traditional CA, in which a user creates an account, adds identifiers to that account (proving control of the domains), and requests certificate issuance for those domains while logged in to the account.</p>
<p id="rfc.section.4.p.2">In ACME, the account is represented by an account key pair.  The &#8220;add a domain&#8221; function is accomplished by authorizing the key pair for a given domain.  Certificate issuance and revocation are authorized by a signature with the key pair.</p>
<p id="rfc.section.4.p.3">The first phase of ACME is for the client to register with the ACME server.  The client generates an asymmetric key pair and associates this key pair with a set of contact information by signing the contact information.  The server acknowledges the registration by replying with a registration object echoing the client&#8217;s input.</p>
<pre>
      Client                                                  Server

      Contact Information
      Signature                     -------&gt;

                                    &lt;-------            Registration
</pre>
<p id="rfc.section.4.p.4">Before a client can issue certificates, it must establish an authorization with the server for an account key pair to act for the identifier(s) that it wishes to include in the certificate.  To do this, the client must demonstrate to the server both (1) that it holds the private key of the account key pair, and (2) that it has authority over the identifier being claimed.</p>
<p id="rfc.section.4.p.5">Proof of possession of the account key is built into the ACME protocol.  All messages from the client to the server are signed by the client, and the server verifies them using the public key of the account key pair.</p>
<p id="rfc.section.4.p.6">To verify that the client controls the identifier being claimed, the server issues the client a set of challenges.  Because there are many different ways to validate possession of different types of identifiers, the server will choose from an extensible set of challenges that are appropriate for the identifier being claimed.  The client responds with a set of responses that tell the server which challenges the client has completed.  The server then validates the challenges to check that the client has accomplished the challenge.</p>
<p id="rfc.section.4.p.7">For example, if the client requests a domain name, the server might challenge the client to provision a record in the DNS under that name, or to provision a file on a web server referenced by an A or AAAA record under that name.  The server would then query the DNS for the record in question, or send an HTTP request for the file.  If the client provisioned the DNS or the web server as expected, then the server considers the client authorized for the domain name.</p>
<pre>
      Client                                                  Server

      Identifier
      Signature                     -------&gt;

                                    &lt;-------              Challenges

      Responses
      Signature                     -------&gt;

                                    &lt;-------       Updated Challenge

                          &lt;~~~~~~~~Validation~~~~~~~~&gt;

      Poll                          -------&gt;

                                    &lt;-------           Authorization
</pre>
<p id="rfc.section.4.p.8">Once the client has authorized an account key pair for an identifier, it can use the key pair to authorize the issuance of certificates for the identifier.  To do this, the client sends a PKCS#10 Certificate Signing Request (CSR) to the server (indicating the identifier(s) to be included in the issued certificate) and a signature over the CSR by the private key of the account key pair.</p>
<p id="rfc.section.4.p.9">If the server agrees to issue the certificate, then it creates the certificate and provides it in its response.  The certificate is assigned a URI, which the client can use to fetch updated versions of the certificate.</p>
<pre>
      Client                                                 Server

      CSR
      Signature                    --------&gt;

                                   &lt;--------            Certificate
</pre>
<p id="rfc.section.4.p.10">To revoke a certificate, the client simply sends a revocation request, signed with an authorized key pair, and the server indicates whether the request has succeeded.</p>
<pre>
      Client                                                 Server

      Revocation request
      Signature                    --------&gt;

                                   &lt;--------                 Result
</pre>
<p id="rfc.section.4.p.11">Note that while ACME is defined with enough flexibility to handle different types of identifiers in principle, the primary use case addressed by this document is the case where domain names are used as identifiers.  For example, all of the identifier validation challenges described in <a href="#identifier-validation-challenges">Section 7</a> below address validation of domain names.  The use of ACME for other protocols will require further specification, in order to describe how these identifiers are encoded in the protocol, and what types of validation challenges the server might require.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#protocol-elements" id="protocol-elements">Protocol Elements</a></h1>
<p id="rfc.section.5.p.1">This section describes several components that are used by ACME, and general rules that apply to ACME transactions.</p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#https-requests" id="https-requests">HTTPS Requests</a></h1>
<p id="rfc.section.5.1.p.1">Each ACME function is accomplished by the client sending a sequence of HTTPS requests to the server, carrying JSON messages.  Use of HTTPS is REQUIRED.  Clients SHOULD support HTTP public key pinning <a href="#RFC7469">[RFC7469]</a>, and servers SHOULD emit pinning headers.  Each subsection of <a href="#certificate-management">Section 6</a> below describes the message formats used by the function, and the order in which messages are sent.</p>
<p id="rfc.section.5.1.p.2">All ACME requests with a non-empty body MUST encapsulate the body in a JWS object, signed using the account key pair.  The server MUST verify the JWS before processing the request.  (For readability, however, the examples below omit this encapsulation.)  Encapsulating request bodies in JWS provides a simple authentication of requests by way of key continuity.</p>
<p id="rfc.section.5.1.p.3">Note that this implies that GET requests are not authenticated.  Servers MUST NOT respond to GET requests for resources that might be considered sensitive.</p>
<p id="rfc.section.5.1.p.4">An ACME request carries a JSON dictionary that provides the details of the client&#8217;s request to the server.  In order to avoid attacks that might arise from sending a request object to a resource of the wrong type, each request object MUST have a &#8220;resource&#8221; field that indicates what type of resource the request is addressed to, as defined in the below table:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Resource type</th>
      <th class="left">&#8220;resource&#8221; value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">New registration</td>
      <td class="left">new-reg</td>
    </tr>
    <tr>
      <td class="left">Recover registration</td>
      <td class="left">recover-reg</td>
    </tr>
    <tr>
      <td class="left">New authorization</td>
      <td class="left">new-authz</td>
    </tr>
    <tr>
      <td class="left">New certificate</td>
      <td class="left">new-cert</td>
    </tr>
    <tr>
      <td class="left">Revoke certificate</td>
      <td class="left">revoke-cert</td>
    </tr>
    <tr>
      <td class="left">Registration</td>
      <td class="left">reg</td>
    </tr>
    <tr>
      <td class="left">Authorization</td>
      <td class="left">authz</td>
    </tr>
    <tr>
      <td class="left">Challenge</td>
      <td class="left">challenge</td>
    </tr>
    <tr>
      <td class="left">Certificate</td>
      <td class="left">cert</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.5.1.p.5">Other fields in ACME request bodies are described below.</p>
<p id="rfc.section.5.1.p.6">ACME servers that are intended to be generally accessible need to use Cross-Origin Resource Sharing (CORS) in order to be accessible from browser-based clients <a href="#W3C.CR-cors-20130129">[W3C.CR-cors-20130129]</a>.  Such servers SHOULD set the Access-Control-Allow-Origin header field to the value &#8220;*&#8221;.</p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#registration-objects" id="registration-objects">Registration Objects</a></h1>
<p id="rfc.section.5.2.p.1">An ACME registration resource represents a set of metadata associated to an account key pair.  Registration resources have the following structure:</p>
<p/>

<dl>
  <dt>key (required, dictionary):</dt>
  <dd style="margin-left: 8">The public key of the account key pair, encoded as a JSON Web Key object <a href="#RFC7517">[RFC7517]</a>.</dd>
  <dt>contact (optional, array of string):</dt>
  <dd style="margin-left: 8">An array of URIs that the server can use to contact the client for issues related to this authorization. For example, the server may wish to notify the client about server-initiated revocation.</dd>
  <dt>agreement (optional, string):</dt>
  <dd style="margin-left: 8">A URI referring to a subscriber agreement or terms of service provided by the server (see below).  Including this field indicates the client&#8217;s agreement with the referenced terms.</dd>
  <dt>authorizations (optional, string):</dt>
  <dd style="margin-left: 8">A URI from which a list of authorizations granted to this account can be fetched via a GET request.  The result of the GET request MUST be a JSON object whose &#8220;authorizations&#8221; field is an array of strings, where each string is the URI of an authorization belonging to this registration.  The server SHOULD include pending authorizations, and SHOULD NOT include authorizations that are invalid or expired.</dd>
  <dt>certificates (optional, string):</dt>
  <dd style="margin-left: 8">A URI from which a list of certificates issued for this account can be fetched via a GET request.  The result of the GET request MUST be a JSON object whose &#8220;certificates&#8221; field is an array of strings, where each string is the URI of a certificate.  The server SHOULD NOT include expired certificates.</dd>
</dl>
<pre>
{
  "resource": "new-reg",
  "contact": [
    "mailto:cert-admin@example.com",
    "tel:+12025551212"
  ],
  "agreement": "https://example.com/acme/terms",
  "authorizations": "https://example.com/acme/reg/1/authz",
  "certificates": "https://example.com/acme/reg/1/cert",
}
</pre>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#authorization-objects" id="authorization-objects">Authorization Objects</a></h1>
<p id="rfc.section.5.3.p.1">An ACME authorization object represents server&#8217;s authorization for an account to represent an identifier.  In addition to the identifier, an authorization includes several metadata fields, such as the status of the authorization (e.g., &#8220;pending&#8221;, &#8220;valid&#8221;, or &#8220;revoked&#8221;) and which challenges were used to validate possession of the identifier.</p>
<p id="rfc.section.5.3.p.2">The structure of an ACME authorization resource is as follows:</p>
<p/>

<dl>
  <dt>identifier (required, dictionary of string):</dt>
  <dd style="margin-left: 8">The identifier that the account is authorized to represent <dl><dt>type (required, string):</dt><dd style="margin-left: 8">The type of identifier.</dd><dt>value (required, string):</dt><dd style="margin-left: 8">The identifier itself.</dd></dl><p> </p></dd>
  <dt>status (optional, string):</dt>
  <dd style="margin-left: 8">The status of this authorization.  Possible values are: &#8220;unknown&#8221;, &#8220;pending&#8221;, &#8220;processing&#8221;, &#8220;valid&#8221;, &#8220;invalid&#8221; and &#8220;revoked&#8221;.  If this field is missing, then the default value is &#8220;pending&#8221;.</dd>
  <dt>expires (optional, string):</dt>
  <dd style="margin-left: 8">The date after which the server will consider this authorization invalid, encoded in the format specified in RFC 3339 <a href="#RFC3339">[RFC3339]</a>.</dd>
  <dt>challenges (required, array):</dt>
  <dd style="margin-left: 8">The challenges that the client needs to fulfill in order to prove possession of the identifier (for pending authorizations).  For final authorizations, the challenges that were used.  Each array entry is a dictionary with parameters required to validate the challenge, as specified in <a href="#identifier-validation-challenges">Section 7</a>.</dd>
  <dt>combinations (optional, array of arrays of integers):</dt>
  <dd style="margin-left: 8">A collection of sets of challenges, each of which would be sufficient to prove possession of the identifier. Clients complete a set of challenges that that covers at least one set in this array. Challenges are identified by their indices in the challenges array.  If no &#8220;combinations&#8221; element is included in an authorization object, the client completes all challenges.</dd>
</dl>
<p id="rfc.section.5.3.p.4">The only type of identifier defined by this specification is a fully-qualified domain name (type: &#8220;dns&#8221;).  The value of the identifier MUST be the ASCII representation of the domain name.  Wildcard domain names (with &#8220;*&#8221; as the first label) MUST NOT be included in authorization requests.  See <a href="#certificate-issuance">Section 6.6</a> below for more information about wildcard domains.</p>
<pre>
{
  "status": "valid",
  "expires": "2015-03-01",

  "identifier": {
    "type": "dns",
    "value": "example.org"
  },

  "challenges": [
    {
      "type": "simpleHttp",
      "status": "valid",
      "validated": "2014-12-01T12:05Z",
      "token": "IlirfxKKXAsHtmzK29Pj8A"
      "path": "Hf5GrX4Q7EBax9hc2jJnfw"
    }
  ],
}
</pre>
<h1 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#errors" id="errors">Errors</a></h1>
<p id="rfc.section.5.4.p.1">Errors can be reported in ACME both at the HTTP layer and within ACME payloads.  ACME servers can return responses with an HTTP error response code (4XX or 5XX).  For example:  If the client submits a request using a method not allowed in this document, then the server MAY return status code 405 (Method Not Allowed).</p>
<p id="rfc.section.5.4.p.2">When the server responds with an error status, it SHOULD provide additional information using problem document <a href="#I-D.ietf-appsawg-http-problem">[I-D.ietf-appsawg-http-problem]</a>.  The &#8220;type&#8221; and &#8220;detail&#8221; fields MUST be populated.  To facilitate automatic response to errors, this document defines the following standard tokens for use in the &#8220;type&#8221; field (within the &#8220;urn:acme:&#8221; namespace):</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Code</th>
      <th class="left">Semantic</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">badCSR</td>
      <td class="left">The CSR is unacceptable (e.g., due to a short key)</td>
    </tr>
    <tr>
      <td class="left">badNonce</td>
      <td class="left">The client sent an unacceptable anti-replay nonce</td>
    </tr>
    <tr>
      <td class="left">connection</td>
      <td class="left">The server could not connect to the client for DV</td>
    </tr>
    <tr>
      <td class="left">dnssec</td>
      <td class="left">The server could not validate a DNSSEC signed domain</td>
    </tr>
    <tr>
      <td class="left">malformed</td>
      <td class="left">The request message was malformed</td>
    </tr>
    <tr>
      <td class="left">serverInternal</td>
      <td class="left">The server experienced an internal error</td>
    </tr>
    <tr>
      <td class="left">tls</td>
      <td class="left">The server experienced a TLS error during DV</td>
    </tr>
    <tr>
      <td class="left">unauthorized</td>
      <td class="left">The client lacks sufficient authorization</td>
    </tr>
    <tr>
      <td class="left">unknownHost</td>
      <td class="left">The server could not resolve a domain name</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.5.4.p.3">Authorization and challenge objects can also contain error information to indicate why the server was unable to validate authorization.</p>
<p id="rfc.section.5.4.p.4">TODO: Flesh out errors and syntax for them</p>
<h1 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a> <a href="#replay-protection" id="replay-protection">Replay protection</a></h1>
<p id="rfc.section.5.5.p.1">In order to protect ACME resources from any possible replay attacks, ACME requests have a mandatory anti-replay mechanism.  This mechanism is based on the server maintaining a list of nonces that it has issued to clients, and requiring any signed request from the client to carry such a nonce.</p>
<p id="rfc.section.5.5.p.2">An ACME server MUST include an Replay-Nonce header field in each successful response it provides to a client, with contents as specified below.  In particular, the ACME server MUST provide a Replay-Nonce header field in response to a HEAD request for any valid resource.  (This allows clients to easily obtain a fresh nonce.)  It MAY also provide nonces in error responses.</p>
<p id="rfc.section.5.5.p.3">Every JWS sent by an ACME client MUST include, in its protected header, the &#8220;nonce&#8221; header parameter, with contents as defined below.  As part of JWS verification, the ACME server MUST verify that the value of the &#8220;nonce&#8221; header is a value that the server previously provided in a Replay-Nonce header field.  Once a nonce value has appeared in an ACME request, the server MUST consider it invalid, in the same way as a value it had never issued.</p>
<p id="rfc.section.5.5.p.4">When a server rejects a request because its nonce value was unacceptable (or not present), it SHOULD provide HTTP status code 400 (Bad Request), and indicate the ACME error code &#8220;urn:acme:badNonce&#8221;.</p>
<p id="rfc.section.5.5.p.5">The precise method used to generate and track nonces is up to the server.  For example, the server could generate a random 128-bit value for each response, keep a list of issued nonces, and strike nonces from this list as they are used.</p>
<h1 id="rfc.section.5.5.1"><a href="#rfc.section.5.5.1">5.5.1.</a> <a href="#replay-nonce" id="replay-nonce">Replay-Nonce</a></h1>
<p id="rfc.section.5.5.1.p.1">The &#8220;Replay-Nonce&#8221; header field includes a server-generated value that the server can use to detect unauthorized replay in future client requests.  The server should generate the value provided in Replay-Nonce in such a way that they are unique to each message, with high probability.</p>
<p id="rfc.section.5.5.1.p.2">The value of the Replay-Nonce field MUST be an octet string encoded according to the base64url encoding described in Section 2 of <a href="#RFC7515">[RFC7515]</a>.  Clients MUST ignore invalid Replay-Nonce values.</p>
<pre>
  base64url = [A-Z] / [a-z] / [0-9] / "-" / "_"

  Replay-Nonce = *base64url
</pre>
<p id="rfc.section.5.5.1.p.3">The Replay-Nonce header field SHOULD NOT be included in HTTP request messages.</p>
<h1 id="rfc.section.5.5.2"><a href="#rfc.section.5.5.2">5.5.2.</a> <a href="#nonce-nonce-jws-header-parameter" id="nonce-nonce-jws-header-parameter">&#8220;nonce&#8221; (Nonce) JWS header parameter</a></h1>
<p id="rfc.section.5.5.2.p.1">The &#8220;nonce&#8221; header parameter provides a unique value that enables the verifier of a JWS to recognize when replay has occurred. The &#8220;nonce&#8221; header parameter MUST be carried in the protected header of the JWS.</p>
<p id="rfc.section.5.5.2.p.2">The value of the &#8220;nonce&#8221; header parameter MUST be an octet string, encoded according to the base64url encoding described in Section 2 of <a href="#RFC7515">[RFC7515]</a>.  If the value of a &#8220;nonce&#8221; header parameter is not valid according to this encoding, then the verifier MUST reject the JWS as malformed.</p>
<h1 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6.</a> <a href="#key-agreement" id="key-agreement">Key Agreement</a></h1>
<p id="rfc.section.5.6.p.1">Certain elements of the protocol will require the establishment of a shared secret between the client and the server, in such a way that an entity observing the ACME protocol cannot derive the secret.  In these cases, we use a simple ECDH key exchange, based on the system used by CMS <a href="#RFC5753">[RFC5753]</a>:</p>
<p/>

<ul>
  <li>Inputs: <ul><li>Client-generated key pair</li><li>Server-generated key pair</li><li>Length of the shared secret to be derived</li><li>Label</li></ul></li>
  <li>Perform the ECDH primitive operation to obtain Z (Section 3.3.1 of <a href="#SEC1">[SEC1]</a>)</li>
  <li>Select a hash algorithm according to the curve being used: <ul><li>For &#8220;P-256&#8221;, use SHA-256</li><li>For &#8220;P-384&#8221;, use SHA-384</li><li>For &#8220;P-521&#8221;, use SHA-512</li></ul></li>
  <li>Derive the shared secret value using the KDF in Section 3.6.1 of <a href="#SEC1">[SEC1]</a> using Z and the selected hash algorithm, and with the UTF-8 encoding of the label as the SharedInfo value</li>
</ul>
<p id="rfc.section.5.6.p.3">In cases where the length of the derived secret is shorter than the output length of the chosen hash algorithm, the KDF referenced above reduces to a single hash invocation.  The shared secret is equal to the leftmost octets of the following:</p>
<pre>
H( Z || 00000001 || label )
</pre>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#certificate-management" id="certificate-management">Certificate Management</a></h1>
<p id="rfc.section.6.p.1">In this section, we describe the certificate management functions that ACME enables:</p>
<p/>

<ul>
  <li>Account Key Registration</li>
  <li>Account Recovery</li>
  <li>Account Key Authorization</li>
  <li>Certificate Issuance</li>
  <li>Certificate Renewal</li>
  <li>Certificate Revocation</li>
</ul>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#resources" id="resources">Resources</a></h1>
<p id="rfc.section.6.1.p.1">ACME is structured as a REST application with a few types of resources:</p>
<p/>

<ul>
  <li>Registration resources, representing information about an account</li>
  <li>Authorization resources, representing an account&#8217;s authorization to act for an identifier</li>
  <li>Challenge resources, representing a challenge to prove control of an identifier</li>
  <li>Certificate resources, representing issued certificates</li>
  <li>A &#8220;directory&#8221; resource</li>
  <li>A &#8220;new-registration&#8221; resource</li>
  <li>A &#8220;new-authorization&#8221; resource</li>
  <li>A &#8220;new-certificate&#8221; resource</li>
  <li>A &#8220;revoke-certificate&#8221; resource</li>
</ul>
<p id="rfc.section.6.1.p.3">For the &#8220;new-X&#8221; resources above, the server MUST have exactly one resource for each function.  This resource may be addressed by multiple URIs, but all must provide equivalent functionality.</p>
<p id="rfc.section.6.1.p.4">In general, the intent is for authorization and certificate resources to contain only public information, so that CAs may publish these resources to document what certificates have been issued and how they were authorized.  Non-public information, such as contact information, is stored in registration resources.</p>
<p id="rfc.section.6.1.p.5">ACME uses different URIs for different management functions. Each function is listed in a directory along with its corresponding URI, so clients only need to be configured with the directory URI.</p>
<p id="rfc.section.6.1.p.6">The &#8220;up&#8221; link relation is used with challenge resources to indicate the authorization resource to which a challenge belongs.  It is also used from certificate resources to indicate a resource from which the client may fetch a chain of CA certificates that could be used to validate the certificate in the original resource.</p>
<p id="rfc.section.6.1.p.7">The following diagram illustrates the relations between resources on an ACME server.  The solid lines indicate link relations, and the dotted lines correspond to relationships expressed in other ways, e.g., the Location header in a 201 (Created) response.</p>
<pre>
                               directory
                                   .
                                   .
       ....................................................
       .                  .                  .            .
       .                  .                  .            .
       V     "next"       V      "next"      V            V
    new-reg ---+----&gt; new-authz ---+----&gt; new-cert    revoke-cert
       .       |          .        |         .            ^
       .       |          .        |         .            | "revoke"
       V       |          V        |         V            |
      reg* ----+        authz -----+       cert-----------+
                         . ^                 |
                         . | "up"            | "up"
                         V |                 V
                       challenge         cert-chain
</pre>
<p id="rfc.section.6.1.p.8">The following table illustrates a typical sequence of requests required to establish a new account with the server, prove control of an identifier, issue a certificate, and fetch an updated certificate some time after issuance.  The &#8220;-&gt;&#8221; is a mnemonic for a Location header pointing to a created resource.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">Action</th>
      <th class="left">Request</th>
      <th class="left">Response</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">Register</td>
      <td class="left">POST new-reg</td>
      <td class="left">201 -&gt; reg</td>
    </tr>
    <tr>
      <td class="left">Request challenges</td>
      <td class="left">POST new-authz</td>
      <td class="left">201 -&gt; authz</td>
    </tr>
    <tr>
      <td class="left">Answer challenges</td>
      <td class="left">POST challenge</td>
      <td class="left">200</td>
    </tr>
    <tr>
      <td class="left">Poll for status</td>
      <td class="left">GET  authz</td>
      <td class="left">200</td>
    </tr>
    <tr>
      <td class="left">Request issuance</td>
      <td class="left">POST new-cert</td>
      <td class="left">201 -&gt; cert</td>
    </tr>
    <tr>
      <td class="left">Check for new cert</td>
      <td class="left">GET  cert</td>
      <td class="left">200</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.1.p.9">The remainder of this section provides the details of how these resources are structured and how the ACME protocol makes use of them.</p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#directory" id="directory">Directory</a></h1>
<p id="rfc.section.6.2.p.1">In order to help clients configure themselves with the right URIs for each ACME operation, ACME servers provide a directory object. This should be the root URL with which clients are configured. It is a JSON dictionary, whose keys are the &#8220;resource&#8221; values listed in <a href="#https-requests">Section 5.1</a>, and whose values are the URIs used to accomplish the corresponding function.</p>
<p id="rfc.section.6.2.p.2">Clients access the directory by sending a GET request to the directory URI.</p>
<pre>
HTTP/1.1 200 OK
Content-Type: application/json

{
  "new-reg": "https://example.com/acme/new-reg",
  "recover-reg": "https://example.com/acme/recover-reg",
  "new-authz": "https://example.com/acme/new-authz",
  "new-cert": "https://example.com/acme/new-cert",
  "revoke-cert": "https://example.com/acme/revoke-cert"
}
</pre>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#registration" id="registration">Registration</a></h1>
<p id="rfc.section.6.3.p.1">A client creates a new account with the server by sending a POST request to the server&#8217;s new-registration URI.  The body of the request is a stub registration object containing only the &#8220;contact&#8221; field (along with the required &#8220;resource&#8221; field).</p>
<pre>
POST /acme/new-registration HTTP/1.1
Host: example.com

{
  "resource": "new-reg",
  "contact": [
    "mailto:cert-admin@example.com",
    "tel:+12025551212"
  ],
}
/* Signed as JWS */
</pre>
<p id="rfc.section.6.3.p.2">The server MUST ignore any values provided in the &#8220;key&#8221;, &#8220;authorizations&#8221;, and &#8220;certificates&#8221; fields in registration bodies sent by the client, as well as any other fields that it does not recognize.  If new fields are specified in the future, the specification of those fields MUST describe whether they may be provided by the client.</p>
<p id="rfc.section.6.3.p.3">The server creates a registration object with the included contact information.  The &#8220;key&#8221; element of the registration is set to the public key used to verify the JWS (i.e., the &#8220;jwk&#8221; element of the JWS header).  The server returns this registration object in a 201 (Created) response, with the registration URI in a Location header field.  The server MUST also indicate its new-authorization URI using the &#8220;next&#8221; link relation.</p>
<p id="rfc.section.6.3.p.4">If the server already has a registration object with the provided account key, then it MUST return a 409 (Conflict) response and provide the URI of that registration in a Location header field.  This allows a client that has an account key but not the corresponding registration URI to recover the registration URI.</p>
<p id="rfc.section.6.3.p.5">If the server wishes to present the client with terms under which the ACME service is to be used, it MUST indicate the URI where such terms can be accessed in a Link header with link relation &#8220;terms-of-service&#8221;.  As noted above, the client may indicate its agreement with these terms by updating its registration to include the &#8220;agreement&#8221; field, with the terms URI as its value.</p>
<pre>
HTTP/1.1 201 Created
Content-Type: application/json
Location: https://example.com/acme/reg/asdf
Link: &lt;https://example.com/acme/new-authz&gt;;rel="next"
Link: &lt;https://example.com/acme/recover-reg&gt;;rel="recover"
Link: &lt;https://example.com/acme/terms&gt;;rel="terms-of-service"

{
  "key": { /* JWK from JWS header */ },

  "contact": [
    "mailto:cert-admin@example.com",
    "tel:+12025551212"
  ]
}
</pre>
<p id="rfc.section.6.3.p.6">If the client wishes to update this information in the future, it sends a POST request with updated information to the registration URI.  The server MUST ignore any updates to the &#8220;key&#8221;, &#8220;authorizations, or &#8220;certificates&#8221; fields, and MUST verify that the request is signed with the private key corresponding to the &#8220;key&#8221; field of the request before updating the registration.</p>
<p id="rfc.section.6.3.p.7">Servers SHOULD NOT respond to GET requests for registration resources as these requests are not authenticated.  If a client wishes to query the server for information about its account (e.g., to examine the &#8220;contact&#8221; or &#8220;certificates&#8221; fields), then it SHOULD do so by sending a POST request with an empty update.  That is, it should send a JWS whose payload is trivial ({&#8220;resource&#8221;:&#8221;reg&#8221;}).</p>
<h1 id="rfc.section.6.3.1"><a href="#rfc.section.6.3.1">6.3.1.</a> <a href="#recovery-keys" id="recovery-keys">Recovery Keys</a></h1>
<p id="rfc.section.6.3.1.p.1">If the client wishes to establish a secret key with the server that it can use to recover this account later (a &#8220;recovery key&#8221;), then it must perform a simple key agreement protocol as part of the new-registration transaction.  The client and server perform an ECDH exchange through the new-registration transaction (using the technique in <a href="#key-agreement">Section 5.6</a>), and the result is the recovery key.</p>
<p id="rfc.section.6.3.1.p.2">To request a recovery key, the client includes a &#8220;recoveryKey&#8221; field in its new-registration request.  The value of this field is a JSON object.</p>
<p/>

<dl>
  <dt>client (required, JWK):</dt>
  <dd style="margin-left: 8">The client&#8217;s ECDH public key</dd>
  <dt>length (required, number):</dt>
  <dd style="margin-left: 8">The length of the derived secret, in octets.</dd>
</dl>
<p id="rfc.section.6.3.1.p.4">In the client&#8217;s request, this object contains a JWK for a random ECDH public key generated by the client and the client-selected length value.  Clients need to choose length values that balance security and usability.  On the one hand, a longer secret makes it makes it more difficult for an attacker to recover the secret when it is used to for recovery (see <a href="#mac-based-recovery">Section 6.4.1</a>).  On the other hand, clients may which to make the recovery key short enough for a user to easily write it down.</p>
<pre>
POST /acme/new-registration HTTP/1.1
Host: example.com

{
  "resource": "new-reg",
  "contact": [
    "mailto:cert-admin@example.com",
    "tel:+12025551212"
  ],
  "recoveryKey": {
    "client": { "kty": "EC", ... },
    "length": 128
  }
}
/* Signed as JWS */
</pre>
<p id="rfc.section.6.3.1.p.5">The server MUST validate that the elliptic curve (&#8220;crv&#8221;) and length value chosen by the client are acceptable, and that is otherwise willing to create a recovery key.  If not, then it MUST reject the new-registration request.</p>
<p id="rfc.section.6.3.1.p.6">If the server agrees to create a recovery key, then it generates its own random ECDH key pair and combines it with with the client&#8217;s public key as described in <a href="#key-agreement">Section 5.6</a> above, using the label &#8220;recovery&#8221;.  The derived secret value is the recovery key.  The server then returns to the client the ECDH key that it generated.  The server MUST generate a fresh key pair for every transaction.</p>
<p/>

<dl>
  <dt>server (required, JWK):</dt>
  <dd style="margin-left: 8">The server&#8217;s ECDH public key</dd>
</dl>
<pre>
HTTP/1.1 201 Created
Content-Type: application/json
Location: https://example.com/acme/reg/asdf

{
  "key": { /* JWK from JWS header */ },

  "contact": [
    "mailto:cert-admin@example.com",
    "tel:+12025551212"
  ],

  "recoveryKey": {
    "server": { "kty": "EC", ... }
  }
}
</pre>
<p id="rfc.section.6.3.1.p.8">On receiving the server&#8217;s response, the client can compute the recovery key by combining the server&#8217;s public key together with the private key corresponding to the public key that it sent to the server.</p>
<p id="rfc.section.6.3.1.p.9">Clients may refresh the recovery key associated with a registration by sending a POST request with a new recoveryKey object.  If the server agrees to refresh the recovery key, then it responds in the same way as to a new registration request that asks for a recovery key.</p>
<pre>
POST /acme/reg/asdf HTTP/1.1
Host: example.com

{
  "resource": "reg",
  "recoveryKey": {
    "client": { "kty": "EC", ... }
  }
}
/* Signed as JWS */
</pre>
<h1 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#account-recovery" id="account-recovery">Account Recovery</a></h1>
<p id="rfc.section.6.4.p.1">Once a client has created an account with an ACME server, it is possible that the private key for the account will be lost.  The recovery contacts included in the registration allows the client to recover from this situation, as long as it still has access to these contacts.</p>
<p id="rfc.section.6.4.p.2">By &#8220;recovery&#8221;, we mean that the information associated with an old account key is bound to a new account key.  When a recovery process succeeds, the server provides the client with a new registration whose contents are the same as base registration object &#8211; except for the &#8220;key&#8221; field, which is set to the new account key.  The server reassigns resources associated with the base registration to the new registration (e.g., authorizations and certificates).  The server SHOULD delete the old registration resource after it has been used as a base for recovery.</p>
<p id="rfc.section.6.4.p.3">In addition to the recovery mechanisms defined by ACME, individual client implementations may also offer implementation-specific recovery mechanisms.  For example, if a client creates account keys deterministically from a seed value, then this seed could be used to recover the account key by re-generating it.  Or an implementation could escrow an encrypted copy of the account key with a cloud storage provider, and give the encryption key to the user as a recovery value.</p>
<h1 id="rfc.section.6.4.1"><a href="#rfc.section.6.4.1">6.4.1.</a> <a href="#mac-based-recovery" id="mac-based-recovery">MAC-Based Recovery</a></h1>
<p id="rfc.section.6.4.1.p.1">With MAC-based recovery, the client proves to the server that it holds a secret value established in the initial registration transaction.  The client requests MAC-based recovery by sending a MAC over the new account key, using the recovery key from the initial registration.</p>
<p/>

<dl>
  <dt>method (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;mac&#8221;</dd>
  <dt>base (required, string):</dt>
  <dd style="margin-left: 8">The URI for the registration to be recovered.</dd>
  <dt>mac (required, string):</dt>
  <dd style="margin-left: 8">A JSON-formatted JWS object using an HMAC algorithm, whose payload is the JWK representation of the public key of the new account key pair.</dd>
</dl>
<pre>
POST /acme/recover-reg HTTP/1.1
Host: example.com

{
  "resource": "recover-reg",
  "method": "mac",
  "base": "https://example.com/acme/reg/asdf",
  "mac": {
    "header": { "alg": "HS256" },
    "payload": base64(JWK(newAccountKey)),
    "signature": "5wUrDI3eAaV4wl2Rfj3aC0Pp--XB3t4YYuNgacv_D3U"
  }
}
/* Signed as JWS, with new account key */
</pre>
<p id="rfc.section.6.4.1.p.3">On receiving such a request the server MUST verify that:</p>
<p/>

<ul>
  <li>The base registration has a recovery key associated with it</li>
  <li>The &#8220;alg&#8221; value in the &#8220;mac&#8221; JWS represents a MAC algorithm</li>
  <li>The &#8220;mac&#8221; JWS is valid according to the validation rules in <a href="#RFC7515">[RFC7515]</a>, using the recovery key as the MAC key</li>
  <li>The JWK in the payload represents the new account key (i.e. the key used to verify the ACME message)</li>
</ul>
<p id="rfc.section.6.4.1.p.5">If those conditions are met, and the recovery request is otherwise acceptable to the server, then the recovery process has succeeded.  The server creates a new registration resource based on the base registration and the new account key, and returns it on a 201 (Created) response, together with a Location header indicating a URI for the new registration.  If the recovery request is unsuccessful, the server returns an error response, such as 403 (Forbidden).</p>
<pre>
HTTP/1.1 201 Created
Content-Type: application/json
Location: https://example.com/acme/reg/asdf
Link: &lt;https://example.com/acme/new-authz&gt;;rel="next"
Link: &lt;https://example.com/acme/recover-reg&gt;;rel="recover"
Link: &lt;https://example.com/acme/terms&gt;;rel="terms-of-service"

{
  "key": { /* JWK from JWS header */ },

  "contact": [
    "mailto:cert-admin@example.com",
    "tel:+12025551212"
  ],

  "authorizations": "...",
  "certificate": "..."
}
</pre>
<h1 id="rfc.section.6.4.2"><a href="#rfc.section.6.4.2">6.4.2.</a> <a href="#contact-based-recovery" id="contact-based-recovery">Contact-Based Recovery</a></h1>
<p id="rfc.section.6.4.2.p.1">In the contact-based recovery process, the client requests that the server send a message to one of the contact URIs registered for the account.  That message indicates some action that the server requires the client&#8217;s user to perform, e.g., clicking a link in an email.  If the user successfully completes the server&#8217;s required actions, then the server will bind the account to the new account key.</p>
<p id="rfc.section.6.4.2.p.2">(Note that this process is almost entirely out of band with respect to ACME.  ACME only allows the client to initiate the process, and the server to indicate the result.)</p>
<p id="rfc.section.6.4.2.p.3">To initiate contact-based recovery, the client sends a POST request to the server&#8217;s recover-registration URI, with a body specifying which registration is to be recovered.  The body of the request MUST be signed by the client&#8217;s new account key pair.</p>
<p/>

<dl>
  <dt>method (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;contact&#8221;</dd>
  <dt>base (required, string):</dt>
  <dd style="margin-left: 8">The URI for the registration to be recovered.</dd>
</dl>
<pre>
POST /acme/recover-reg HTTP/1.1
Host: example.com

{
  "resource": "recover-reg",
  "method": "contact",
  "base": "https://example.com/acme/reg/asdf"
}
/* Signed as JWS, with new account key */
</pre>
<p id="rfc.section.6.4.2.p.5">If the server agrees to attempt contact-based recovery, then it creates a new registration resource containing a stub registration object.  The stub registration has the client&#8217;s new account key and anonymized contacts, in order to allow the client to know which contacts to check.  The server returns the stub contact in a 201 (Created) response, along with a Location header field indicating the URI for the new registration resource (which will be the registration URI if the recovery succeeds).</p>
<pre>
HTTP/1.1 201 Created
Content-Type: application/json
Location: https://example.com/acme/reg/qwer

{
  "key": { /* new account key from JWS header */ },

  "contact": [
    "mailto:c********n@example.com",
    "tel:+1********12"
  ]
}
</pre>
<p id="rfc.section.6.4.2.p.6">After recovery has been initiated, the server follows its chosen recovery process, out-of-band to ACME.  While the recovery process is ongoing, the client may poll the registration resource&#8217;s URI for status, by sending a POST request with a trivial body ({&#8220;resource&#8221;:&#8221;reg&#8221;}).  If the recovery process is still pending, the server sends a 202 (Accepted) status code, and a Retry-After header field. If the recovery process has failed, the server sends an error code (e.g., 404), and SHOULD delete the stub registration resource.</p>
<p id="rfc.section.6.4.2.p.7">If the recovery process has succeeded, then the server will send a 200 (OK) response, containing the full registration object (copied from the old registration).  The client may now use this in the same way as if he had gotten it from a new-registration transaction.</p>
<h1 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a> <a href="#identifier-authorization" id="identifier-authorization">Identifier Authorization</a></h1>
<p id="rfc.section.6.5.p.1">The identifier authorization process establishes the authorization of an account to manage certificates for a given identifier.  This process must assure the server of two things: First, that the client controls the private key of the account key pair, and second, that the client holds the identifier in question.  This process may be repeated to associate multiple identifiers to a key pair (e.g., to request certificates with multiple identifiers), or to associate multiple accounts with an identifier (e.g., to allow multiple entities to manage certificates).</p>
<p id="rfc.section.6.5.p.2">As illustrated by the figure in the overview section above, the authorization process proceeds in two phases.  The client first requests a new authorization, and the server issues challenges, then the client responds to those challenges and the server validates the client&#8217;s responses.</p>
<p id="rfc.section.6.5.p.3">To begin the key authorization process, the client sends a POST request to the server&#8217;s new-authorization resource.  The body of the POST request MUST contain a JWS object, whose payload is a partial authorization object.  This JWS object MUST contain only the &#8220;identifier&#8221; field, so that the server knows what identifier is being authorized.  The server MUST ignore any other fields present in the client&#8217;s request object.</p>
<p id="rfc.section.6.5.p.4">The authorization object is implicitly tied to the account key used to sign the request. Once created, the authorization may only be updated by that account.</p>
<pre>
POST /acme/new-authorization HTTP/1.1
Host: example.com

{
  "resource": "new-authz",
  "identifier": {
    "type": "dns",
    "value": "example.org"
  }
}
/* Signed as JWS */
</pre>
<p id="rfc.section.6.5.p.5">Before processing the authorization further, the server SHOULD determine whether it is willing to issue certificates for the identifier.  For example, the server should check that the identifier is of a supported type.  Servers might also check names against a blacklist of known high-value identifiers.  If the server is unwilling to issue for the identifier, it SHOULD return a 403 (Forbidden) error, with a problem document describing the reason for the rejection.</p>
<p id="rfc.section.6.5.p.6">If the server is willing to proceed, it builds a pending authorization object from the initial authorization object submitted by the client.</p>
<p/>

<ul>
  <li>&#8220;identifier&#8221; the identifier submitted by the client.</li>
  <li>&#8220;status&#8221;: MUST be &#8220;pending&#8221;</li>
  <li>&#8220;challenges&#8221; and &#8220;combinations&#8221;: As selected by the server&#8217;s policy for this identifier</li>
  <li>The &#8220;expires&#8221; field MUST be absent.</li>
</ul>
<p id="rfc.section.6.5.p.8">The server allocates a new URI for this authorization, and returns a 201 (Created) response, with the authorization URI in a Location header field, and the JSON authorization object in the body.</p>
<pre>
HTTP/1.1 201 Created
Content-Type: application/json
Location: https://example.com/authz/asdf
Link: &lt;https://example.com/acme/new-cert&gt;;rel="next"

{
  "status": "pending",

  "identifier": {
    "type": "dns",
    "value": "example.org"
  },

  "challenges": [
    {
      "type": "simpleHttp",
      "uri": "https://example.com/authz/asdf/0",
      "token": "IlirfxKKXAsHtmzK29Pj8A"
    },
    {
      "type": "dns",
      "uri": "https://example.com/authz/asdf/1"
      "token": "DGyRejmCefe7v4NfDGDKfA"
    }
  },

  "combinations": [
    [0, 2],
    [1, 2]
  ]
}
</pre>
<p id="rfc.section.6.5.p.9">The client needs to respond with information to complete the challenges.  To do this, the client updates the authorization object received from the server by filling in any required information in the elements of the &#8220;challenges&#8221; dictionary.  For example, if the client wishes to complete the &#8220;simpleHttp&#8221; challenge, it needs to provide the &#8220;path&#8221; component.  (This is also the stage where the client should perform any actions required by the challenge.)</p>
<p id="rfc.section.6.5.p.10">The client sends these updates back to the server in the form of a JSON object with the response fields required by the challenge type, carried in a POST request to the challenge URI (not authorization URI or the new-authorization URI).  This allows the client to send information only for challenges it is responding to.</p>
<p id="rfc.section.6.5.p.11">For example, if the client were to respond to the &#8220;simpleHttp&#8221; challenge in the above authorization, it would send the following request:</p>
<pre>
POST /acme/authz/asdf/0 HTTP/1.1
Host: example.com

{
  "resource": "challenge",
  "type": "simpleHttp",
  "path": "Hf5GrX4Q7EBax9hc2jJnfw"
}
/* Signed as JWS */
</pre>
<p id="rfc.section.6.5.p.12">The server updates the authorization document by updating its representation of the challenge with the response fields provided by the client.  The server MUST ignore any fields in the response object that are not specified as response fields for this type of challenge.  The server provides a 200 (OK) response with the updated challenge object as its body.</p>
<p id="rfc.section.6.5.p.13">Presumably, the client&#8217;s responses provide the server with enough information to validate one or more challenges.  The server is said to &#8220;finalize&#8221; the authorization when it has completed all the validations it is going to complete, and assigns the authorization a status of &#8220;valid&#8221; or &#8220;invalid&#8221;, corresponding to whether it considers the account authorized for the identifier.  If the final state is &#8220;valid&#8221;, the server MUST add an &#8220;expires&#8221; field to the authorization.  When finalizing an authorization, the server MAY remove the &#8220;combinations&#8221; field (if present) or remove any challenges still pending.  The server SHOULD NOT remove challenges with status &#8220;invalid&#8221;.</p>
<p id="rfc.section.6.5.p.14">Usually, the validation process will take some time, so the client will need to poll the authorization resource to see when it is finalized.  For challenges where the client can tell when the server has validated the challenge (e.g., by seeing an HTTP or DNS request from the server), the client SHOULD NOT begin polling until it has seen the validation request from the server.</p>
<p id="rfc.section.6.5.p.15">To check on the status of an authorization, the client sends a GET request to the authorization URI, and the server responds with the current  authorization object. In responding to poll requests while the validation is still in progress, the server MUST return a 202 (Accepted) response with a Retry-After header field.</p>
<pre>
GET /acme/authz/asdf HTTP/1.1
Host: example.com

HTTP/1.1 200 OK

{
  "status": "valid",
  "expires": "2015-03-01",

  "identifier": {
    "type": "dns",
    "value": "example.org"
  },

  "challenges": [
    {
      "type": "simpleHttp"
      "status": "valid",
      "validated": "2014-12-01T12:05Z",
      "token": "IlirfxKKXAsHtmzK29Pj8A"
      "path": "Hf5GrX4Q7EBax9hc2jJnfw"
    }
  ]
}
</pre>
<h1 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6.</a> <a href="#certificate-issuance" id="certificate-issuance">Certificate Issuance</a></h1>
<p id="rfc.section.6.6.p.1">The holder of an authorized key pair for an identifier may use ACME to request that a certificate be issued for that identifier.  The client makes this request by sending a POST request to the server&#8217;s new-certificate resource.  The body of the POST is a JWS object whose JSON payload contains a Certificate Signing Request (CSR) <a href="#RFC2986">[RFC2986]</a>.  The CSR encodes the parameters of the requested certificate; authority to issue is demonstrated by the JWS signature by an account key, from which the server can look up related authorizations.</p>
<p/>

<dl>
  <dt>csr (required, string):</dt>
  <dd style="margin-left: 8">A CSR encoding the parameters for the certificate being requested.  The CSR is sent in the Base64-encoded version of the DER format.  (Note: This field uses the same modified Base64-encoding rules used elsewhere in this document, so it is different from PEM.)</dd>
</dl>
<pre>
POST /acme/new-cert HTTP/1.1
Host: example.com
Accept: application/pkix-cert

{
  "resource": "new-cert",
  "csr": "5jNudRx6Ye4HzKEqT5...FS6aKdZeGsysoCo4H9P",
}
/* Signed as JWS */
</pre>
<p id="rfc.section.6.6.p.3">The CSR encodes the client&#8217;s requests with regard to the content of the certificate to be issued.  The CSR MUST indicate the requested identifiers, either in the commonName portion of the requested subject name, or in an extensionRequest attribute <a href="#RFC2985">[RFC2985]</a> requesting a subjectAltName extension.</p>
<p id="rfc.section.6.6.p.4">The values provided in the CSR are only a request, and are not guaranteed.  The server or CA may alter any fields in the certificate before issuance.  For example, the CA may remove identifiers that are not authorized for the account key that signed the request.</p>
<p id="rfc.section.6.6.p.5">It is up to the server&#8217;s local policy to decide which names are acceptable in a certificate, given the authorizations that the server associates with the client&#8217;s account key.  A server MAY consider a client authorized for a wildcard domain if it is authorized for the underlying domain name (without the &#8220;*&#8221; label).  Servers SHOULD NOT extend authorization across identifier types.  For example, if a client is authorized for &#8220;example.com&#8221;, then the server should not allow the client to issue a certificate with an iPAddress subjectAltName, even if it contains an IP address to which example.com resolves.</p>
<p id="rfc.section.6.6.p.6">If the CA decides to issue a certificate, then the server creates a new certificate resource and returns a URI for it in the Location header field of a 201 (Created) response.</p>
<pre>
HTTP/1.1 201 Created
Location: https://example.com/acme/cert/asdf
</pre>
<p id="rfc.section.6.6.p.7">If the certificate is available at the time of the response, it is provided in the body of the response.  If the CA has not yet issued the certificate, the body of this response will be empty.  The client should then send a GET request to the certificate URI to poll for the certificate.  As long as the certificate is unavailable, the server MUST provide a 202 (Accepted) response and include a Retry-After header to indicate when the server believes the certificate will be issued (as in the example above).</p>
<pre>
GET /acme/cert/asdf HTTP/1.1
Host: example.com
Accept: application/pkix-cert

HTTP/1.1 202 Accepted
Retry-After: 120
</pre>
<p id="rfc.section.6.6.p.8">The default format of the certificate is DER (application/pkix-cert).  The client may request other formats by including an Accept header in its request.</p>
<p id="rfc.section.6.6.p.9">The server provides metadata about the certificate in HTTP headers.  In particular, the server MUST include a Link relation header field <a href="#RFC5988">[RFC5988]</a> with relation &#8220;up&#8221; to provide a certificate under which this certificate was issued.  The server MAY also include an Expires header as a hint to the client about when to renew the certificate.  (Of course, the real expiration of the certificate is controlled by the notAfter time in the certificate itself.)</p>
<pre>
GET /acme/cert/asdf HTTP/1.1
Host: example.com
Accept: application/pkix-cert

HTTP/1.1 200 OK
Content-Type: application/pkix-cert
Link: &lt;https://example.com/acme/ca-cert&gt;;rel="up";title="issuer"
Link: &lt;https://example.com/acme/revoke-cert&gt;;rel="revoke"
Location: https://example.com/acme/cert/asdf
Content-Location: https://example.com/acme/cert-seq/12345

[DER-encoded certificate]
</pre>
<h1 id="rfc.section.6.7"><a href="#rfc.section.6.7">6.7.</a> <a href="#certificate-renewal" id="certificate-renewal">Certificate Renewal</a></h1>
<p id="rfc.section.6.7.p.1">Often, a client wishes to request a new certificate with the same contents as another certificates, but with updated notBefore and notAfter dates.  This operation is referred to as &#8220;renewal&#8221; of the certificate.</p>
<p id="rfc.section.6.7.p.2">If the CA allows a certificate to be renewed, then it publishes renewed versions of the certificate through the same certificate URI.  Clients retrieve renewed versions of the certificate using a GET query to the certificate URI, which the server should then return in a 200 (OK) response.  The server SHOULD provide a URI for each specific certificate in the Content-Location header field, as shown above.  Requests to specific certificate URIs MUST always result in the same certificate.</p>
<p id="rfc.section.6.7.p.3">To avoid unnecessary renewals, the CA may choose not to issue a renewed certificate until it receives such a request.  In such cases, if the CA requires some time to generate the new certificate, the CA MUST return a 202 (Accepted) response, with a Retry-After header field that indicates when the new certificate will be available.  The CA MAY include the current (non-renewed) certificate as the body of the response.</p>
<p id="rfc.section.6.7.p.4">From the client&#8217;s perspective, there is no difference between a certificate URI that allows renewal and one that does not.  If the client wishes to obtain a renewed certificate, and a GET request to the certificate URI does not yield one, then the client may initiate a new-certificate transaction to request one.</p>
<h1 id="rfc.section.6.8"><a href="#rfc.section.6.8">6.8.</a> <a href="#certificate-revocation" id="certificate-revocation">Certificate Revocation</a></h1>
<p id="rfc.section.6.8.p.1">To request that a certificate be revoked, the client sends a POST request to the ACME server&#8217;s revoke-cert URI.  The body of the POST is a JWS object whose JSON payload contains the certificate to be revoked:</p>
<p/>

<dl>
  <dt>certificate (required, string):</dt>
  <dd style="margin-left: 8">The certificate to be revoked, in the Base64-encoded version of the DER format.  (Note: This field uses the same modified Base64-encoding rules used elsewhere in this document, so it is different from PEM.)</dd>
</dl>
<pre>
POST /acme/revoke-cert HTTP/1.1
Host: example.com

{
  "resource": "revoke-cert",
  "certificate": "MIIEDTCCAvegAwIBAgIRAP8..."
}
/* Signed as JWS */
</pre>
<p id="rfc.section.6.8.p.3">Revocation requests are different from other ACME request in that they can be signed either with an account key pair or the key pair in the certificate.  Before revoking a certificate, the server MUST verify at least one of these conditions applies:</p>
<p/>

<ul>
  <li>the public key of the key pair signing the request matches the public key in the certificate.</li>
  <li>the key pair signing the request is an account key, and the corresponding account is authorized to act for all of the identifier(s) in the certificate.</li>
</ul>
<p id="rfc.section.6.8.p.5">If the revocation succeeds, the server responds with status code 200 (OK).  If the revocation fails, the server returns an error.</p>
<pre>
HTTP/1.1 200 OK
Content-Length: 0

--- or ---

HTTP/1.1 403 Forbidden
Content-Type: application/problem+json
Content-Language: en

{
  "type": "urn:acme:error:unauthorized"
  "detail": "No authorization provided for name example.net"
  "instance": "http://example.com/doc/unauthorized"
}
</pre>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#identifier-validation-challenges" id="identifier-validation-challenges">Identifier Validation Challenges</a></h1>
<p id="rfc.section.7.p.1">There are few types of identifier in the world for which there is a standardized mechanism to prove possession of a given identifier.  In all practical cases, CAs rely on a variety of means to test whether an entity applying for a certificate with a given identifier actually controls that identifier.</p>
<p id="rfc.section.7.p.2">Challenges provide the server with assurance the an account key holder is also the entity that controls an identifier.  For each type of challenge, it must be the case that in order for an entity to successfully complete the challenge the entity must both:</p>
<p/>

<ul>
  <li>Hold the private key of the account key pair used to respond to the challenge</li>
  <li>Control the identifier in question</li>
</ul>
<p><a href="#security-considerations">Section 9</a> documents how the challenges defined in this document meet these requirements.  New challenges will need to document how they do.</p>
<p id="rfc.section.7.p.5">To accommodate this reality, ACME includes an extensible challenge/response framework for identifier validation.  This section describes an initial set of Challenge types.  Each challenge must describe:</p>
<p/>

<ul>
  <li>Content of Challenge payloads (in Challenge messages)</li>
  <li>Content of Response payloads (in authorizationRequest messages)</li>
  <li>How the server uses the Challenge and Response to verify control of an identifier</li>
</ul>
<p id="rfc.section.7.p.7">The general structure of Challenge and Response payloads is as follows:</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The type of Challenge or Response encoded in the object.</dd>
  <dt>uri (required, string):</dt>
  <dd style="margin-left: 8">The URI to which a response can be posted.</dd>
</dl>
<p id="rfc.section.7.p.9">status (optional, string): : The status of this authorization.  Possible values are: &#8220;unknown&#8221;, &#8220;pending&#8221;, &#8220;processing&#8221;, &#8220;valid&#8221;, &#8220;invalid&#8221; and &#8220;revoked&#8221;.  If this field is missing, then the default value is &#8220;pending&#8221;.</p>
<p id="rfc.section.7.p.10">validated (optional, string): : The time at which this challenge was completed by the server, encoded in the format specified in RFC 3339 <a href="#RFC3339">[RFC3339]</a>.</p>
<p id="rfc.section.7.p.11">error (optional, dictionary of string): : The error that occurred while the server was validating the challenge, if any.  This field is structured as a problem document <a href="#I-D.ietf-appsawg-http-problem">[I-D.ietf-appsawg-http-problem]</a>.</p>
<p id="rfc.section.7.p.12">All additional fields are specified by the Challenge type.  The server MUST ignore any values provided in the &#8220;uri&#8221;, &#8220;status&#8221;, &#8220;validated&#8221;, and &#8220;error&#8221; fields of a Response payload.  If the server sets a Challenge&#8217;s &#8220;status&#8221; to &#8220;invalid&#8221;, it SHOULD also include the &#8220;error&#8221; field to help the client diagnose why they failed the challenge.</p>
<p id="rfc.section.7.p.13">Different challenges allow the server to obtain proof of different aspects of control over an identifier.  In some challenges, like Simple HTTP and DVSNI, the client directly proves its ability to do certain things related to the identifier.  In the Proof of Possession challenge, the client proves historical control of the identifier, by reference to a prior authorization transaction or certificate.</p>
<p id="rfc.section.7.p.14">The choice of which Challenges to offer to a client under which circumstances is a matter of server policy.  A CA may choose different sets of challenges depending on whether it has interacted with a domain before, and how.  For example:</p>
<p/>

<ul>
  <li>New domain with no known certificates: Domain Validation (DVSNI or Simple HTTP)</li>
  <li>Domain for which known certs exist from other CAs: DV + Proof of Possession of previous CA-signed key</li>
  <li>Domain with a cert from this CA, lost account key: DV + PoP of ACME-certified Subject key</li>
  <li>Domain with a cert from this CA, all keys and recovery tokens lost: Out of band proof of authority for the domain</li>
</ul>
<p id="rfc.section.7.p.16">The identifier validation challenges described in this section all relate to validation of domain names.  If ACME is extended in the future to support other types of identifier, there will need to be new Challenge types, and they will need to specify which types of identifier they apply to.</p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#simple-http" id="simple-http">Simple HTTP</a></h1>
<p id="rfc.section.7.1.p.1">With Simple HTTP validation, the client in an ACME transaction proves its control over a domain name by proving that it can provision resources on an HTTP server that responds for that domain name.  The ACME server challenges the client to provision a file with a specific string as its contents.</p>
<p id="rfc.section.7.1.p.2">As a domain may resolve to multiple IPv4 and IPv6 addresses, the server will connect to at least one of the hosts found in A and AAAA records, at its discretion.  The HTTP server may be made available over either HTTPS or unencrypted HTTP; the client tells the server in its response which to check.</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;simpleHttp&#8221;</dd>
  <dt>token (required, string):</dt>
  <dd style="margin-left: 8">The value to be provisioned in the file.  This value MUST have at least 128 bits of entropy, in order to prevent an attacker from guessing it.  It MUST NOT contain any non-ASCII characters.</dd>
</dl>
<pre>
{
  "type": "simpleHttp",
  "token": "evaGxfADs6pSRb2LAv9IZf17Dt3juxGJ+PCt92wr+oA"
}
</pre>
<p id="rfc.section.7.1.p.4">A client responds to this challenge by signing a JWS object and provisioning it as a resource on the HTTP server for the domain in question.  The payload of the JWS MUST be a JSON dictionary containing the fields &#8220;type&#8221;, &#8220;token&#8221;, &#8220;path&#8221;, and &#8220;tls&#8221; from the ACME challenge and response (see below), and no other fields.  If the &#8220;tls&#8221; field is not included in the response, then validation object MUST have its &#8220;tls&#8221; field set to &#8220;true&#8221;.  The JWS MUST be signed with the client&#8217;s account key pair. This JWS is NOT REQUIRED to have a &#8220;nonce&#8221; header parameter (as with the JWS objects that carry ACME request objects), but MUST otherwise meet the guidelines laid out in <a href="#terminology">Section 3</a>.</p>
<pre>
{
  "type": "simpleHttp",
  "token": "evaGxfADs6pSRb2LAv9IZf17Dt3juxGJ+PCt92wr+oA",
  "path": "6tbIMBC5Anhl5bOlWT5ZFA",
  "tls": false,
}
</pre>
<p id="rfc.section.7.1.p.5">The path at which the resource is provisioned is determined by the client, but MUST begin with &#8220;.well-known/acme-challenge/&#8221;.  The content type of the resource, if provided, MUST be &#8220;application/jose+json&#8221;.  In addition to expressing the path in the JWS as described above, the client returns the part of the path coming after that prefix in its Response message.</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;simpleHttp&#8221;</dd>
  <dt>path (required, string):</dt>
  <dd style="margin-left: 8">The string to be appended to the standard prefix &#8220;.well-known/acme-challenge/&#8221; in order to form the path at which the nonce resource is provisioned.  The value MUST be comprised entirely of characters from the URL-safe alphabet for Base64 encoding <a href="#RFC4648">[RFC4648]</a>, and MUST NOT be longer than 25 characters (sufficient for 128 bits of base64-encoded data).</dd>
  <dt>tls (optional, boolean, default true):</dt>
  <dd style="margin-left: 8">If this attribute is present and set to &#8220;false&#8221;, the server will perform its validation check over unencrypted HTTP (on port 80) rather than over HTTPS.  Otherwise the check will be done over HTTPS, on port 443.</dd>
</dl>
<pre>
{
  "type": "simpleHttp",
  "path": "6tbIMBC5Anhl5bOlWT5ZFA",
  "tls": false
}
/* Signed as JWS */
</pre>
<p id="rfc.section.7.1.p.7">Given a Challenge/Response pair, the server verifies the client&#8217;s control of the domain by verifying that the resource was provisioned as expected.</p>
<p/>

<ol>
  <li>Form a URI by populating the URI template <a href="#RFC6570">[RFC6570]</a> &#8220;{scheme}://{domain}/.well-known/acme-challenge/{path}&#8221;, where: <ul><li>the scheme field is set to &#8220;http&#8221; if the &#8220;tls&#8221; field in the response is present and set to false, and &#8220;https&#8221; otherwise;</li><li>the domain field is set to the domain name being verified; and</li><li>the path field is the path provided in the response.</li></ul></li>
  <li>Verify that the resulting URI is well-formed.</li>
  <li>Dereference the URI using an HTTP or HTTPS GET request.  If using HTTPS, the ACME server MUST ignore the certificate provided by the HTTPS server.</li>
  <li>Verify that the Content-Type header of the response is either absent, or has the value &#8220;application/jose+json&#8221;</li>
  <li>Verify that the body of the response is a valid JWS of the type indicated by the Content-Type header (if present), signed with the client&#8217;s account key</li>
  <li>Verify that the payload of the JWS meets the following criteria: <ul><li>It is a valid JSON dictionary</li><li>It has exactly four fields</li><li>Its &#8220;type&#8221; field is set to &#8220;simpleHttp&#8221;</li><li>Its &#8220;token&#8221; field is equal to the &#8220;token&#8221; field in the challenge</li><li>Its &#8220;path&#8221; field is equal to the &#8220;path&#8221; field in the response</li><li>Its &#8220;tls&#8221; field is equal to the &#8220;tls&#8221; field in the response, or &#8220;true&#8221; if the &#8220;tls&#8221; field was absent</li></ul></li>
</ol>
<p id="rfc.section.7.1.p.9">Comparisons of the &#8220;path&#8221; and &#8220;token&#8221; fields MUST be performed in terms of Unicode code points, taking into account the encodings of the stored nonce and the body of the request.</p>
<p id="rfc.section.7.1.p.10">If all of the above verifications succeed, then the validation is successful.  If the request fails, or the body does not pass these checks, then it has failed.</p>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#domain-validation-with-server-name-indication-dvsni" id="domain-validation-with-server-name-indication-dvsni">Domain Validation with Server Name Indication (DVSNI)</a></h1>
<p id="rfc.section.7.2.p.1">The Domain Validation with Server Name Indication (DVSNI) validation method aims to ensure that the ACME client has administrative access to the web server at the domain name being validated, and possession of the private key being authorized.  The ACME server verifies that the operator can reconfigure the web server by having the client create a new self-signed challenge certificate and respond to TLS connections from the ACME server with it.</p>
<p id="rfc.section.7.2.p.2">The challenge proceeds as follows: The ACME server sends the client a random value R and a nonce used to identify the transaction.  The client responds with another random value S.  The server initiates a TLS connection on port 443 to one or more of the IPv4 or IPv6 hosts with the domain name being validated.  In the handshake, the ACME server sets the Server Name Indication extension set to &#8220;&lt;nonce&gt;.acme.invalid&#8221;.  The TLS server (i.e., the ACME client) should respond with a valid self-signed certificate containing both the domain name being validated and the domain name &#8220;&lt;Z&gt;.acme.invalid&#8221;, where Z = SHA-256(R || S).</p>
<p id="rfc.section.7.2.p.3">The ACME server&#8217;s Challenge provides its random value R, and a random nonce used to identify the transaction:</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;dvsni&#8221;</dd>
  <dt>r (required, string):</dt>
  <dd style="margin-left: 8">A random 32-byte octet, Base64-encoded</dd>
  <dt>nonce (required, string):</dt>
  <dd style="margin-left: 8">A random 16-byte octet string, hex-encoded (so that it can be used as a DNS label)</dd>
</dl>
<pre>
{
  "type": "dvsni",
  "r": "Tyq0La3slT7tqQ0wlOiXnCY2vyez7Zo5blgPJ1xt5xI",
  "nonce": "a82d5ff8ef740d12881f6d3c2277ab2e"
}
</pre>
<p id="rfc.section.7.2.p.5">The client responds to this Challenge by configuring a TLS server on port 443 of a server with the domain name being validated:</p>
<p/>

<ol>
  <li>Decode the server&#8217;s random value R</li>
  <li>Generate a random 32-byte octet string S</li>
  <li>Compute Z = SHA-256(R || S) (where || denotes concatenation of octet strings)</li>
  <li>Generate a self-signed certificate with a subjectAltName extension containing two dNSName values:</li>
  <li>The domain name being validated</li>
  <li>A name formed by hex-encoding Z and appending the suffix &#8220;.acme.invalid&#8221;</li>
  <li>Compute a nonce domain name by appending the suffix &#8220;.acme.invalid&#8221; to the nonce provided by the server.</li>
  <li>Configure the TLS server such that when a client presents the nonce domain name in the SNI field, the server presents the generated certificate.</li>
</ol>
<p id="rfc.section.7.2.p.7">The client&#8217;s response provides its random value S:</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;dvsni&#8221;</dd>
  <dt>s (required, string):</dt>
  <dd style="margin-left: 8">A random 32-byte secret octet string, Base64-encoded</dd>
</dl>
<pre>
{
  "type": "dvsni",
  "s": "9dbjsl3gTAtOnEtKFEmhS6Mj-ajNjDcOmRkp3Lfzm3c"
}
</pre>
<p id="rfc.section.7.2.p.9">Given a Challenge/Response pair, the ACME server verifies the client&#8217;s control of the domain by verifying that the TLS server was configured as expected:</p>
<p/>

<ol>
  <li>Compute the value Z = SHA-256(R || S)</li>
  <li>Open a TLS connection to the domain name being validated on port 443, presenting the value &#8220;&lt;nonce&gt;.acme.invalid&#8221; in the SNI field.</li>
  <li>Verify the following properties of the certificate provided by the TLS server: <ul><li>It is a valid self-signed certificate</li><li>The public key is the public key for the key pair being authorized</li><li>It contains the domain name being validated as a subjectAltName</li><li>It contains a subjectAltName matching the hex-encoding of Z, with the suffix &#8220;.acme.invalid&#8221;</li></ul></li>
</ol>
<p id="rfc.section.7.2.p.11">It is RECOMMENDED that the ACME server verify the challenge certificate using multi-path probing techniques to reduce the risk of DNS hijacking attacks.</p>
<p id="rfc.section.7.2.p.12">If the server presents a certificate matching all of the above criteria, then the validation is successful.  Otherwise, the validation fails.</p>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#proof-of-possession-of-a-prior-key" id="proof-of-possession-of-a-prior-key">Proof of Possession of a Prior Key</a></h1>
<p id="rfc.section.7.3.p.1">The Proof of Possession challenge verifies that a client possesses a private key corresponding to a server-specified public key, as demonstrated by its ability to sign with that key.  This challenge is meant to be used when the server knows of a public key that is already associated with the identifier being claimed, and wishes for new authorizations to be authorized by the holder of the corresponding private key.  For DNS identifiers, for example, this can help guard against domain hijacking.</p>
<p id="rfc.section.7.3.p.2">This method is useful if a server policy calls for issuing a certificate only to an entity that already possesses the subject private key of a particular prior related certificate (perhaps issued by a different CA).  It may also help enable other kinds of server policy that are related to authenticating a client&#8217;s identity using digital signatures.</p>
<p id="rfc.section.7.3.p.3">This challenge proceeds in much the same way as the proof of possession of the authorized key pair in the main ACME flow (challenge + authorizationRequest).  The server provides a nonce and the client signs over the nonce.  The main difference is that rather than signing with the private key of the key pair being authorized, the client signs with a private key specified by the server.  The server can specify which key pair(s) are acceptable directly (by indicating a public key), or by asking for the key corresponding to a certificate.</p>
<p id="rfc.section.7.3.p.4">The server provides the following fields as part of the challenge:</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;proofOfPossession&#8221;</dd>
  <dt>identifier (required, identifier):</dt>
  <dd style="margin-left: 8">The ACME identifier for which authorization is being validated</dd>
  <dt>hints (required, object):</dt>
  <dd style="margin-left: 8">A JSON object that contains various clues for the client about what the requested key is, such that the client can find it.  Entries in the hints object may include: <dl><dt>jwks (required, array of JWK):</dt><dd style="margin-left: 8">A JSON Web Key object describing acceptable public keys</dd><dt>certs (optional, array of string):</dt><dd style="margin-left: 8">An array of certificates, in Base64-encoded DER format, that contain acceptable public keys.</dd></dl><p> </p></dd>
</dl>
<pre>
{
  "type": "proofOfPossession",
  "hints": {
    "jwk": {
      "kty": "RSA",
      "e": "AQAB",
      "n": "AMswMT...3aVtjE"
    },
    "certs": ["MIIF7z...bYVQLY"]
  }
}
</pre>
<p id="rfc.section.7.3.p.6">In response to this challenge, the client uses the private key corresponding to one of the acceptable public keys to sign a JWS object including data related to the challenge.  The validation object covered by the signature has the following fields:</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;proofOfPossession&#8221;</dd>
  <dt>identifiers (required, identifier):</dt>
  <dd style="margin-left: 8">A list of identifiers for which the holder of the prior key authorizes the new key</dd>
  <dt>accountKey (required, JWK):</dt>
  <dd style="margin-left: 8">The client&#8217;s account public key</dd>
</dl>
<pre>
{
  "type": "proofOfPossession",
  "identifiers: [{"type": "dns", "value": "example.com"}],
  "accountKey": { "kty": "RSA", ... }
}
</pre>
<p id="rfc.section.7.3.p.8">This JWS is NOT REQUIRED to have a &#8220;nonce&#8221; header parameter (as with the JWS objects that carry ACME request objects).  This allows proof-of-possession response objects to be computed off-line.  For example, as part of a domain transfer, the new domain owner might require the old domain owner to sign a proof-of-possession validation object, so that the new domain owner can present that in an ACME transaction later.</p>
<p id="rfc.section.7.3.p.9">The validation JWS MUST contain a &#8220;jwk&#8221; header parameter indicating the public key under which the server should verify the JWS.</p>
<p id="rfc.section.7.3.p.10">The client&#8217;s response includes the server-provided nonce, together with a signature over that nonce by one of the private keys requested by the server.</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;proofOfPossession&#8221;</dd>
  <dt>authorization (required, JWS):</dt>
  <dd style="margin-left: 8">The validation JWS</dd>
</dl>
<pre>
{
  "type": "proofOfPossession",
  "authorization": {
    "header": {
      "alg": "RS256",
      "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "n": "AMswMT...3aVtjE"
      }
    },
    "payload": "SfiR1...gSAl7A",
    "signature": "XcQLfL...cW5beg"
  }
}
</pre>
<p id="rfc.section.7.3.p.12">To validate a proof-of-possession challenge, the server performs the following steps:</p>
<p/>

<ol>
  <li>Verify that the public key in the &#8220;jwk&#8221; header of the &#8220;authorization&#8221; JWS is one of the keys listed in the challenge&#8217;s &#8220;hints&#8221; section</li>
  <li>Verify the &#8220;authorization&#8221; JWS using the key indicated in its &#8220;jwk&#8221; header</li>
  <li>Decode the payload of the JWS as UTF-8 encoded JSON</li>
  <li>Verify that there are exactly three fields in the decoded object, and that: <ul><li>The &#8220;type&#8221; field is set to &#8220;proofOfPossession&#8221;</li><li>The &#8220;identifier&#8221; field contains the identifier for which authorization is being validated</li><li>The &#8220;accountKey&#8221; field matches the account key for which the challenge was issued</li></ul></li>
</ol>
<p id="rfc.section.7.3.p.14">If all of the above verifications succeed, then the validation is successful.  Otherwise, the validation fails.</p>
<h1 id="rfc.section.7.4"><a href="#rfc.section.7.4">7.4.</a> <a href="#dns" id="dns">DNS</a></h1>
<p id="rfc.section.7.4.p.1">When the identifier being validated is a domain name, the client can prove control of that domain by provisioning resource records under it.   The DNS challenge requires the client to provision a TXT record containing a designated value under a specific validation domain name.</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;dns&#8221;</dd>
  <dt>token (required, string):</dt>
  <dd style="margin-left: 8">A random value with at least 128 bits of entropy.  It MUST NOT contain any characters outside the URL-safe Base64 alphabet.</dd>
</dl>
<pre>
{
  "type": "dns",
  "token": "evaGxfADs6pSRb2LAv9IZf17Dt3juxGJ+PCt92wr+oA",
}
</pre>
<p id="rfc.section.7.4.p.3">In response to this challenge, the client uses its account private key to sign a JWS over a JSON object describing the challenge.  The validation object covered by the signature MUST have the following fields and no others:</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;dns&#8221;</dd>
  <dt>token (required, string):</dt>
  <dd style="margin-left: 8">The token value in the challenge</dd>
</dl>
<pre>
{
  "type": "dns",
  "token": "evaGxfADs6pSRb2LAv9IZf17Dt3juxGJ+PCt92wr+oA",
}
</pre>
<p id="rfc.section.7.4.p.5">The client serializes the validation object to UTF-8, then uses its account private key to sign a JWS with the serialized JSON object as its payload.  This JWS is NOT REQUIRED to have the &#8220;nonce&#8221; header parameter.</p>
<p id="rfc.section.7.4.p.6">The record provisioned to the DNS is the &#8220;signature&#8221; value from the JWS, i.e., the base64-encoded signature value.  The client constructs the validation domain name by appending the label &#8220;_acme-challenge&#8221; to the domain name being validated, then provisions a TXT record with the signature value under that name. For example, if the domain name being validated is &#8220;example.com&#8221;, then the client would provision the following DNS record:</p>
<pre>
_acme-challenge.example.com. 300 IN TXT "gfj9Xq...Rg85nM"
</pre>
<p id="rfc.section.7.4.p.7">The response to a DNS challenge provides the validation JWS to the server.</p>
<p/>

<dl>
  <dt>type (required, string):</dt>
  <dd style="margin-left: 8">The string &#8220;dns&#8221;</dd>
  <dt>validation (required, JWS):</dt>
  <dd style="margin-left: 8">The JWS object computed with the validation object and the derived key</dd>
</dl>
<pre>
{
  "type": "dns"
  "clientPublicKey": { "kty": "EC", ... },
  "validation": {
    "header": { "alg": "HS256" },
    "payload": "qzu9...6bjn",
    "signature": "gfj9XqFv07e1wU66hSLYkiFqYakPSjAu8TsyXRg85nM"
  }
}
</pre>
<p id="rfc.section.7.4.p.9">To validate a DNS challenge, the server performs the following steps:</p>
<p/>

<ol>
  <li>Verify the validation JWS using the account key for which this challenge was issued</li>
  <li>Decode the payload of the JWS as UTF-8 encoded JSON</li>
  <li>Verify that there are exactly two fields in the decoded object, and that: <ul><li>The &#8220;type&#8221; field is set to &#8220;dns&#8221;</li><li>The &#8220;token&#8221; field matches the &#8220;token&#8221; value in the challenge</li></ul></li>
  <li>Query for TXT records under the validation domain name</li>
  <li>Verify that the contents of one of the TXT records match the &#8220;signature&#8221; value in the &#8220;validation&#8221; JWS</li>
</ol>
<p id="rfc.section.7.4.p.11">If all of the above verifications succeed, then the validation is successful.  If no DNS record is found, or DNS record and response payload do not pass these checks, then the validation fails.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.8.p.1">TODO</p>
<p/>

<ul>
  <li>Register .well-known path</li>
  <li>Register Replay-Nonce HTTP header</li>
  <li>Register &#8220;nonce&#8221; JWS header parameter</li>
  <li>Register &#8220;urn:acme&#8221; namespace</li>
  <li>Create identifier validation method registry</li>
  <li>Registries of syntax tokens, e.g., message types / error types?</li>
</ul>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.9.p.1">ACME is a protocol for managing certificates that attest to identifier/key bindings.  Thus the foremost security goal of ACME is to ensure the integrity of this process, i.e., to ensure that the bindings attested by certificates are correct, and that only authorized entities can manage certificates.  ACME identifies clients by their account keys, so this overall goal breaks down into two more precise goals:</p>
<p/>

<ol>
  <li>Only an entity that controls a identifier can get an account key authorized for that identifier</li>
  <li>Once authorized, an account key&#8217;s authorizations cannot be improperly transferred to another account key</li>
</ol>
<p id="rfc.section.9.p.3">In this section, we discuss the threat model that underlies ACME and the ways that ACME achieves these security goals within that threat model.  We also discuss the denial-of-service risks that ACME servers face, and a few other miscellaneous considerations.</p>
<h1 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> <a href="#threat-model" id="threat-model">Threat model</a></h1>
<p id="rfc.section.9.1.p.1">As a service on the Internet, ACME broadly exists within the Internet threat model <a href="#RFC3552">[RFC3552]</a>.  In analyzing ACME, it is useful to think of an ACME server interacting with other Internet hosts along three &#8220;channels&#8221;:</p>
<p/>

<ul>
  <li>An ACME channel, over which the ACME HTTPS requests are exchanged</li>
  <li>A validation channel, over which the ACME server performs additional requests to validate a client&#8217;s control of an identifier</li>
  <li>A contact channel, over which the ACME server sends messages to the registered contacts for ACME clients</li>
</ul>
<pre>
+------------+
|    ACME    |     ACME Channel
|   Client   |--------------------+
+------------+                    |
       ^                          V
       |   Contact Channel  +------------+
       +--------------------|    ACME    |
                            |   Server   |
                            +------------+
+------------+                    |
| Validation |&lt;-------------------+
|   Server   |  Validation Channel
+------------+
</pre>
<p id="rfc.section.9.1.p.3">In practice, the risks to these channels are not entirely separate, but they are different in most cases.  Each of the three channels, for example, uses a different communications pattern: the ACME channel will comprise inbound HTTPS connections to the ACME server, the validation channel outbound HTTP or DNS requests, and the contact channel will use channels such as email and PSTN.</p>
<p id="rfc.section.9.1.p.4">Broadly speaking, ACME aims to be secure against active and passive attackers on any individual channel.  Some vulnerabilities arise (noted below), when an attacker can exploit both the ACME channel and one of the others.</p>
<p id="rfc.section.9.1.p.5">On the ACME channel, in addition to network-layer attackers, we also need to account for application-layer man in the middle attacks, and for abusive use of the protocol itself.  Protection against application-layer MitM addresses potential attackers such as Content Distribution Networks (CDNs) and middleboxes with a TLS MitM function.  Preventing abusive use of ACME means ensuring that an attacker with access to the validation or contact channels can&#8217;t obtain illegitimate authorization by acting as an ACME client (legitimately, in terms of the protocol).</p>
<h1 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a> <a href="#integrity-of-authorizations" id="integrity-of-authorizations">Integrity of Authorizations</a></h1>
<p id="rfc.section.9.2.p.1">ACME allows anyone to request challenges for an identifier by registering an account key and sending a new-authorization request under that account key.  The integrity of the authorization process thus depends on the identifier validation challenges to ensure that the challenge can only be completed by someone who both (1) holds the private key of the account key pair, and (2) controls the identifier in question.</p>
<p id="rfc.section.9.2.p.2">Validation resposnes need to be bound to an account key pair in order to avoid situations where an ACME MitM can switch out a legitimate domain holder&#8217;s account key for one of his choosing, e.g.:</p>
<p/>

<ul>
  <li>Legitimate domain holder registers account key pair A</li>
  <li>MitM registers account key pair B</li>
  <li>Legitimate domain holder sends a new-authorization request signed under account key A</li>
  <li>MitM suppresses the legitimate request, but sends the same request signed under account key B</li>
  <li>ACME server issues challenges and MitM forwards them to the legitimate domain holder</li>
  <li>Legitimate domain holder provisions the validation response</li>
  <li>ACME server performs validation query and sees the response provisioned by the legitimate domain holder</li>
  <li>Because the challenges were issued in response to a message signed account key B, the ACME server grants authoriztion to account key B (the MitM) instead of account key A (the legitimate domain holder)</li>
</ul>
<p id="rfc.section.9.2.p.4">All of the challenges above that require an out-of-band query by the server have a binding to the account private key, such that the only the account private key holder can successfully respond to the validation query:</p>
<p/>

<ul>
  <li>Simple HTTP: The value provided in the validation request is signed by the account private key.</li>
  <li>DVSNI: The validation TLS request uses the account key pair as the server&#8217;s key pair.</li>
  <li>DNS: The MAC covers the account key, and the MAC key is derived from an ECDH public key signed with the accont private key.</li>
  <li>Proof of possession of a prior key: The signature by the prior key covers the account public key.</li>
</ul>
<p id="rfc.section.9.2.p.6">The association of challenges to identifiers is typically done by requiring the client to perform some action that only someone who effectively controls the identifier can perform.  For the challenges in this document, the actions are:</p>
<p/>

<ul>
  <li>Simple HTTP: Provision files under .well-known on a web server for the domain</li>
  <li>DVSNI: Configure a TLS server for the domain</li>
  <li>DNS: Provision DNS resource records for the domain</li>
  <li>Proof of possession of a prior key: Sign using the private key specified by the server</li>
</ul>
<p id="rfc.section.9.2.p.8">There are several ways that these assumptions can be violated, both by misconfiguration and by attack.  For example, on a web server that allows non-administrative users to write to .well-known, any user can claim to own the server&#8217;s hostname by responding to a Simple HTTP challenge, and likewise for TLS configuration and DVSNI.</p>
<p id="rfc.section.9.2.p.9">The use of hosting providers is a particular risk for ACME validation.  If the owner of the domain has outsourced operation of DNS or web services to a hosting provider, there is nothing that can be done against tampering by the hosting provider.  As far as the outside world is concerned, the zone or web site provided by the hosting provider is the real thing.</p>
<p id="rfc.section.9.2.p.10">The DNS is a common point of vulnerability for all of these challenges.  An entity that can provision false DNS records for a domain can attack the DNS challenge directly, and can provision false A/AAAA records to direct the ACME server to send its DVSNI or Simple HTTP validation query to a server of the attacker&#8217;s choosing.  There are a few different mitigations that ACME servers can apply:</p>
<p/>

<ul>
  <li>Checking the DNSSEC status of DNS records used in ACME validation (for zones that are DNSSEC-enabled)</li>
  <li>Querying the DNS from multiple vantage points to address local attackers</li>
  <li>Applying mitigations against DNS off-path attackers, e.g., adding entropy to requests <a href="#I-D.vixie-dnsext-dns0x20">[I-D.vixie-dnsext-dns0x20]</a> or only using TCP</li>
</ul>
<p id="rfc.section.9.2.p.12">Given these considerations, the ACME validation process makes it impossible for any attacker on the ACME channel, or a passive attacker on the validation channel to hijack the authorization process to authorize a key of the attacker&#8217;s choice.</p>
<p id="rfc.section.9.2.p.13">An attacker that can only see the ACME channel would need to convince the validation server to provide a response that would authorize the attacker&#8217;s account key, but this is prevented by binding the validation response to the account key used to request challenges.  A passive attacker on the validation channel can observe the correct validation response and even replay it, but that response can only be used with the account key for which it was generated.</p>
<p id="rfc.section.9.2.p.14">An active attacker on the validation channel can subvert the ACME process, by performing normal ACME transactions and providing a validation response for his own account key.  The risks due to hosting providers noted above are a particular case.  For identifiers where the server already has some credential associated with the domain this attack can be prevented by requiring the client to complete a proof-of-possession challenge.</p>
<h1 id="rfc.section.9.3"><a href="#rfc.section.9.3">9.3.</a> <a href="#preventing-authorization-hijacking" id="preventing-authorization-hijacking">Preventing Authorization Hijacking</a></h1>
<p id="rfc.section.9.3.p.1">The account recovery processes described in <a href="#account-recovery">Section 6.4</a> allow authorization to be transferred from one account key to another, in case the former account key pair&#8217;s private key is lost.  ACME needs to prevent these processes from being exploited by an attacker to hijack the authorizations attached to one key and assign them to a key of the attacker&#8217;s choosing.</p>
<p id="rfc.section.9.3.p.2">Recovery takes place in two steps: 1. Provisioning recovery information (contact or recovery key) 2. Using recovery information to recover an account</p>
<p id="rfc.section.9.3.p.3">The provisioning process needs to ensure that only the account key holder ends up with information that is useful for recovery.  The recovery process needs to assure that only the (now former) account key holder can successfully execute recovery, i.e., that this entity is the only one that can choose the new account key that receives the capabilities held by the account being recovered.</p>
<p id="rfc.section.9.3.p.4">MAC-based recovery can be performed if the attacker knows the account key and registration URI for the account being recovered.  Both of these are difficult to obtain for a network attacker, because ACME usess HTTPS), though if the recovery key and registration URI are sufficiently preductable, the attacker might be able to guess them.  An ACME MitM can see the registration URI, but still has to guess the recovery key, since neitherthe ECDH in the provisioning phase nor HMAC in the recovery phase will reveal it to him.</p>
<p id="rfc.section.9.3.p.5">ACME clients can thus mitigate problems with MAC-based recovery by using long recovery keys.  ACME servers should enforce a minimum recovery key length, and impose rate limits on recovery to limit an attacker&#8217;s ability to test different guesses about the recovery key.</p>
<p id="rfc.section.9.3.p.6">Contact-based recovery uses both the ACME channel and the contact channel.  The provisioning process is only visible to an ACME MitM, and even then, the MitM can only observe the contact information provided.  If the ACME attacker does not also have access to the contact channel, there is no risk.</p>
<p id="rfc.section.9.3.p.7">The security of the contact-based recovery process is entirely dependent on the security of the contact channel.  The details of this will depend on the specific out-of-band technique used by the server.  For example:</p>
<p/>

<ul>
  <li>If the server requires a user to click a link in a message sent to a contact address, then the contact channel will need to ensure that the message is only available to the legitimate owner of the contact address.  Otherwise, a passive attacker could see the link and click it first, or an active attacker could redirect the message.</li>
  <li>If the server requires a user to respond to a message sent to a contact address containing a secret value, then the contact channel will need to ensure that an attacker cannot observe the secret value and spoof a message from the contact address.</li>
</ul>
<p id="rfc.section.9.3.p.9">In practice, many contact channels that can be used to reach many clients do not provide strong assurances of the types noted above.  In designing and deploying contact-based recovery schemes, ACME servers operators will need to find an appropriate balance between using contact channels that can reach many clients and using contact-based recovery schemes that acheive an appropriate level of risk using those contact channels.</p>
<h1 id="rfc.section.9.4"><a href="#rfc.section.9.4">9.4.</a> <a href="#denial-of-service-considerations" id="denial-of-service-considerations">Denial-of-Service Considerations</a></h1>
<p id="rfc.section.9.4.p.1">As a protocol run over HTTPS, standard considerations for TCP-based and HTTP-based DoS mitigation also apply to ACME.</p>
<p id="rfc.section.9.4.p.2">At the application layer, ACME requires the server to perform a few potentially expensive operations.  Identifier validation transactions require the ACME server to make outbound connections to potentially attacker-controlled servers, and certificate issuance can require interactions with cryptographic hardware.</p>
<p id="rfc.section.9.4.p.3">In addition, an attacker can also cause the ACME server to send validation requests to a domain of its choosing by submitting authorization requests for the victim domain.</p>
<p id="rfc.section.9.4.p.4">All of these attacks can be mitigated by the application of appropriate rate limits.  Issues closer to the front end, like POST body validation, can be addressed using HTTP request limiting.  For validation and certificate requests, there are other identifiers on which rate limits can be keyed.  For example, the server might limit the rate at which any individual account key can issue certificates, or the rate at which validation can be requested within a given subtree of the DNS.</p>
<h1 id="rfc.section.9.5"><a href="#rfc.section.9.5">9.5.</a> <a href="#ca-policy-considerations" id="ca-policy-considerations">CA Policy Considerations</a></h1>
<p id="rfc.section.9.5.p.1">The controls on issuance enabled by ACME are focused on validating that a certificate applicant controls the identifier he claims.  Before issuing a certificate, however, there are many other checks that a CA might need to perform, for example:</p>
<p/>

<ul>
  <li>Has the client agreed to a subscriber agreement?</li>
  <li>Is the claimed identifier syntactically valid?</li>
  <li>For domain names: <ul><li>If the leftmost label is a &#8216;*&#8217;, then have the appropriate checks been applied?</li><li>Is the name on the Public Suffix List?</li><li>Is the name a high-value name?</li><li>Is the name a known phishing domain?</li></ul></li>
  <li>Is the key in the CSR sufficiently strong?</li>
  <li>Is the CSR signed with an acceptable algorithm?</li>
</ul>
<p id="rfc.section.9.5.p.3">CAs that use ACME to automate issuance will need to ensure that their servers perform all necessary checks before issuing.</p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.10.p.1">In addition to the editors listed on the front page, this document has benefited from contributions from a broad set of contributors, all the way back to its inception.</p>
<p/>

<ul>
  <li>Peter Eckersley, EFF</li>
  <li>Eric Rescorla, Mozilla</li>
  <li>Seth Schoen, EFF</li>
  <li>Alex Halderman, University of Michigan</li>
  <li>Martin Thomson, Mozilla</li>
  <li>Jakub Warmuz, University of Oxford</li>
</ul>
<p id="rfc.section.10.p.3">This document draws on many concepts established by Eric Rescorla&#8217;s &#8220;Automated Certificate Issuance Protocol&#8221; draft.  Martin Thomson provided helpful guidance in the use of HTTP.</p>
<h1 id="rfc.references"><a href="#rfc.references">11.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">11.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-appsawg-http-problem">[I-D.ietf-appsawg-http-problem]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a> and <a>E. Wilde</a>, "<a href="http://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00">Problem Details for HTTP APIs</a>", Internet-Draft draft-ietf-appsawg-http-problem-00, September 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2314">[RFC2314]</b>
      </td>
      <td class="top"><a href="mailto:burt@rsa.com" title="RSA Laboratories East">Kaliski, B.</a>, "<a href="http://tools.ietf.org/html/rfc2314">PKCS #10: Certification Request Syntax Version 1.5</a>", RFC 2314, March 1998.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2985">[RFC2985]</b>
      </td>
      <td class="top"><a>Nystrom, M.</a> and <a>B. Kaliski</a>, "<a href="http://tools.ietf.org/html/rfc2985">PKCS #9: Selected Object Classes and Attribute Types Version 2.0</a>", RFC 2985, November 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2986">[RFC2986]</b>
      </td>
      <td class="top"><a>Nystrom, M.</a> and <a>B. Kaliski</a>, "<a href="http://tools.ietf.org/html/rfc2986">PKCS #10: Certification Request Syntax Specification Version 1.7</a>", RFC 2986, November 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3339">[RFC3339]</b>
      </td>
      <td class="top"><a href="mailto:GK@ACM.ORG" title="Clearswift Corporation">Klyne, G.</a> and <a href="mailto:chris.newman@sun.com" title="Sun Microsystems">C. Newman</a>, "<a href="http://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>", RFC 3339, July 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3986">[RFC3986]</b>
      </td>
      <td class="top"><a href="mailto:timbl@w3.org" title="World Wide Web Consortium">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com" title="Day Software">Fielding, R.</a> and <a href="mailto:LMM@acm.org" title="Adobe Systems Incorporated">L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, January 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4514">[RFC4514]</b>
      </td>
      <td class="top"><a>Zeilenga, K.</a>, "<a href="http://tools.ietf.org/html/rfc4514">Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names</a>", RFC 4514, June 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4648">[RFC4648]</b>
      </td>
      <td class="top"><a>Josefsson, S.</a>, "<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, October 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5226">[RFC5226]</b>
      </td>
      <td class="top"><a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 5226, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5280">[RFC5280]</b>
      </td>
      <td class="top"><a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5753">[RFC5753]</b>
      </td>
      <td class="top"><a>Turner, S.</a> and <a>D. Brown</a>, "<a href="http://tools.ietf.org/html/rfc5753">Use of Elliptic Curve Cryptography (ECC) Algorithms in Cryptographic Message Syntax (CMS)</a>", RFC 5753, January 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5988">[RFC5988]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a>, "<a href="http://tools.ietf.org/html/rfc5988">Web Linking</a>", RFC 5988, October 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6570">[RFC6570]</b>
      </td>
      <td class="top"><a>Gregorio, J.</a>, <a>Fielding, R.</a>, <a>Hadley, M.</a>, <a>Nottingham, M.</a> and <a>D. Orchard</a>, "<a href="http://tools.ietf.org/html/rfc6570">URI Template</a>", RFC 6570, March 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7159">[RFC7159]</b>
      </td>
      <td class="top"><a>Bray, T.</a>, "<a href="http://tools.ietf.org/html/rfc7159">The JavaScript Object Notation (JSON) Data Interchange Format</a>", RFC 7159, March 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7469">[RFC7469]</b>
      </td>
      <td class="top"><a>Evans, C.</a>, <a>Palmer, C.</a> and <a>R. Sleevi</a>, "<a href="http://tools.ietf.org/html/rfc7469">Public Key Pinning Extension for HTTP</a>", RFC 7469, April 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7515">[RFC7515]</b>
      </td>
      <td class="top"><a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="http://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a>", RFC 7515, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7517">[RFC7517]</b>
      </td>
      <td class="top"><a>Jones, M.</a>, "<a href="http://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a>", RFC 7517, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7518">[RFC7518]</b>
      </td>
      <td class="top"><a>Jones, M.</a>, "<a href="http://tools.ietf.org/html/rfc7518">JSON Web Algorithms (JWA)</a>", RFC 7518, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SEC1">[SEC1]</b>
      </td>
      <td class="top"><a>Standards for Efficient Cryptography Group</a>, "<a href="http://www.secg.org/sec1-v2.pdf">SEC 1: Elliptic Curve Cryptography</a>", May 2009.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">11.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.vixie-dnsext-dns0x20">[I-D.vixie-dnsext-dns0x20]</b>
      </td>
      <td class="top"><a>Vixie, P.</a> and <a>D. Dagon</a>, "<a href="http://tools.ietf.org/html/draft-vixie-dnsext-dns0x20-00">Use of Bit 0x20 in DNS Labels to Improve Transaction Identity</a>", Internet-Draft draft-vixie-dnsext-dns0x20-00, March 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2818">[RFC2818]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>", RFC 2818, May 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3552">[RFC3552]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="W3C.CR-cors-20130129">[W3C.CR-cors-20130129]</b>
      </td>
      <td class="top"><a>Kesteren, A.</a>, "<a href="http://www.w3.org/TR/2013/CR-cors-20130129">Cross-Origin Resource Sharing</a>", World Wide Web Consortium CR CR-cors-20130129, January 2013.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Richard Barnes</span> 
	  <span class="n hidden">
		<span class="family-name">Barnes</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:rlb@ipv.sx">rlb@ipv.sx</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jacob Hoffman-Andrews</span> 
	  <span class="n hidden">
		<span class="family-name">Hoffman-Andrews</span>
	  </span>
	</span>
	<span class="org vcardline">EFF</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jsha@eff.org">jsha@eff.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">James Kasten</span> 
	  <span class="n hidden">
		<span class="family-name">Kasten</span>
	  </span>
	</span>
	<span class="org vcardline">University of Michigan</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jdkasten@umich.edu">jdkasten@umich.edu</a></span>

  </address>
</div>

</body>
</html>
